//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import followIfLoginRedirect from '../components/api-authorization/followIfLoginRedirect';
import store from "../lib/store"

export class AddressClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    post(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Address";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<FileResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(request: LoginRequest): Promise<TokenRequest> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<TokenRequest> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenRequest>(null as any);
    }

    register(request: RegisterRequest): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<FileResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    refresh(refreshToken: string | undefined): Promise<TokenRequest> {
        let url_ = this.baseUrl + "/api/Auth/refresh?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<TokenRequest> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenRequest>(null as any);
    }

    info(): Promise<TokenRequest> {
        let url_ = this.baseUrl + "/api/Auth/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfo(_response);
        });
    }

    protected processInfo(response: Response): Promise<TokenRequest> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenRequest>(null as any);
    }
}

export class BlogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfBlogMapping> {
        let url_ = this.baseUrl + "/api/Blog?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfBlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfBlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfBlogMapping>(null as any);
    }

    createEntity(entity: BlogCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Blog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<BlogMapping> {
        let url_ = this.baseUrl + "/api/Blog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<BlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlogMapping>(null as any);
    }

    updateEntity(id: number, entity: BlogUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Blog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Blog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class CourseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfCourseMapping> {
        let url_ = this.baseUrl + "/api/Course?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfCourseMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfCourseMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfCourseMapping>(null as any);
    }

    createEntity(entity: CourseCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<CourseMapping> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<CourseMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseMapping>(null as any);
    }

    updateEntity(id: number, entity: CourseUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class SubjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfSubjectMapping> {
        let url_ = this.baseUrl + "/api/Subject?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfSubjectMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfSubjectMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfSubjectMapping>(null as any);
    }

    createEntity(entity: SubjectCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Subject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<SubjectMapping> {
        let url_ = this.baseUrl + "/api/Subject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<SubjectMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubjectMapping>(null as any);
    }

    updateEntity(id: number, entity: SubjectUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Subject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Subject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class TokenRequest implements ITokenRequest {
    accessToken?: string;
    refreshToken?: string;

    constructor(data?: ITokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): TokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ITokenRequest {
    accessToken?: string;
    refreshToken?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    username?: string;
    password?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    username?: string;
    password?: string;
}

export class PagingModelOfBlogMapping implements IPagingModelOfBlogMapping {
    items?: BlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlogMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfBlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfBlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfBlogMapping {
    items?: BlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class BlogMapping implements IBlogMapping {
    id?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlog[];
    likeBlogs?: LikeBlog[];

    constructor(data?: IBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.title = _data["title"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            if (Array.isArray(_data["commentBlogs"])) {
                this.commentBlogs = [] as any;
                for (let item of _data["commentBlogs"])
                    this.commentBlogs!.push(CommentBlog.fromJS(item));
            }
            if (Array.isArray(_data["likeBlogs"])) {
                this.likeBlogs = [] as any;
                for (let item of _data["likeBlogs"])
                    this.likeBlogs!.push(LikeBlog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new BlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["title"] = this.title;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.commentBlogs)) {
            data["commentBlogs"] = [];
            for (let item of this.commentBlogs)
                data["commentBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.likeBlogs)) {
            data["likeBlogs"] = [];
            for (let item of this.likeBlogs)
                data["likeBlogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogMapping {
    id?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlog[];
    likeBlogs?: LikeBlog[];
}

export class User implements IUser {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    createTime?: Date;
    avatar?: string;
    email?: string;
    updateTime?: Date;
    password?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string;
    userStatus?: UserStatus;
    district?: District;
    province?: Province;
    certificate?: Certificate;
    ward?: Ward;
    answers?: Answers[];
    bills?: Bill[];
    blogs?: Blog[];
    commentBlogs?: CommentBlog[];
    confirmEmails?: ConfirmEmail[];
    courses?: Course[];
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];
    likeBlogs?: LikeBlog[];
    makeQuestions?: MakeQuestion[];
    notifications?: Notification[];
    permissions?: Permission[];
    refreshTokens?: RefreshToken[];
    registerStudies?: RegisterStudy[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.certificateId = _data["certificateId"];
            this.wardId = _data["wardId"];
            this.username = _data["username"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.email = _data["email"];
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.address = _data["address"];
            this.userStatus = _data["userStatus"];
            this.district = _data["district"] ? District.fromJS(_data["district"]) : <any>undefined;
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : <any>undefined;
            this.certificate = _data["certificate"] ? Certificate.fromJS(_data["certificate"]) : <any>undefined;
            this.ward = _data["ward"] ? Ward.fromJS(_data["ward"]) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answers.fromJS(item));
            }
            if (Array.isArray(_data["bills"])) {
                this.bills = [] as any;
                for (let item of _data["bills"])
                    this.bills!.push(Bill.fromJS(item));
            }
            if (Array.isArray(_data["blogs"])) {
                this.blogs = [] as any;
                for (let item of _data["blogs"])
                    this.blogs!.push(Blog.fromJS(item));
            }
            if (Array.isArray(_data["commentBlogs"])) {
                this.commentBlogs = [] as any;
                for (let item of _data["commentBlogs"])
                    this.commentBlogs!.push(CommentBlog.fromJS(item));
            }
            if (Array.isArray(_data["confirmEmails"])) {
                this.confirmEmails = [] as any;
                for (let item of _data["confirmEmails"])
                    this.confirmEmails!.push(ConfirmEmail.fromJS(item));
            }
            if (Array.isArray(_data["courses"])) {
                this.courses = [] as any;
                for (let item of _data["courses"])
                    this.courses!.push(Course.fromJS(item));
            }
            if (Array.isArray(_data["doHomeworks"])) {
                this.doHomeworks = [] as any;
                for (let item of _data["doHomeworks"])
                    this.doHomeworks!.push(DoHomework.fromJS(item));
            }
            if (Array.isArray(_data["learningProgresses"])) {
                this.learningProgresses = [] as any;
                for (let item of _data["learningProgresses"])
                    this.learningProgresses!.push(LearningProgress.fromJS(item));
            }
            if (Array.isArray(_data["likeBlogs"])) {
                this.likeBlogs = [] as any;
                for (let item of _data["likeBlogs"])
                    this.likeBlogs!.push(LikeBlog.fromJS(item));
            }
            if (Array.isArray(_data["makeQuestions"])) {
                this.makeQuestions = [] as any;
                for (let item of _data["makeQuestions"])
                    this.makeQuestions!.push(MakeQuestion.fromJS(item));
            }
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(Notification.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
            if (Array.isArray(_data["refreshTokens"])) {
                this.refreshTokens = [] as any;
                for (let item of _data["refreshTokens"])
                    this.refreshTokens!.push(RefreshToken.fromJS(item));
            }
            if (Array.isArray(_data["registerStudies"])) {
                this.registerStudies = [] as any;
                for (let item of _data["registerStudies"])
                    this.registerStudies!.push(RegisterStudy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["certificateId"] = this.certificateId;
        data["wardId"] = this.wardId;
        data["username"] = this.username;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["email"] = this.email;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["address"] = this.address;
        data["userStatus"] = this.userStatus;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["certificate"] = this.certificate ? this.certificate.toJSON() : <any>undefined;
        data["ward"] = this.ward ? this.ward.toJSON() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.bills)) {
            data["bills"] = [];
            for (let item of this.bills)
                data["bills"].push(item.toJSON());
        }
        if (Array.isArray(this.blogs)) {
            data["blogs"] = [];
            for (let item of this.blogs)
                data["blogs"].push(item.toJSON());
        }
        if (Array.isArray(this.commentBlogs)) {
            data["commentBlogs"] = [];
            for (let item of this.commentBlogs)
                data["commentBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.confirmEmails)) {
            data["confirmEmails"] = [];
            for (let item of this.confirmEmails)
                data["confirmEmails"].push(item.toJSON());
        }
        if (Array.isArray(this.courses)) {
            data["courses"] = [];
            for (let item of this.courses)
                data["courses"].push(item.toJSON());
        }
        if (Array.isArray(this.doHomeworks)) {
            data["doHomeworks"] = [];
            for (let item of this.doHomeworks)
                data["doHomeworks"].push(item.toJSON());
        }
        if (Array.isArray(this.learningProgresses)) {
            data["learningProgresses"] = [];
            for (let item of this.learningProgresses)
                data["learningProgresses"].push(item.toJSON());
        }
        if (Array.isArray(this.likeBlogs)) {
            data["likeBlogs"] = [];
            for (let item of this.likeBlogs)
                data["likeBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.makeQuestions)) {
            data["makeQuestions"] = [];
            for (let item of this.makeQuestions)
                data["makeQuestions"].push(item.toJSON());
        }
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.refreshTokens)) {
            data["refreshTokens"] = [];
            for (let item of this.refreshTokens)
                data["refreshTokens"].push(item.toJSON());
        }
        if (Array.isArray(this.registerStudies)) {
            data["registerStudies"] = [];
            for (let item of this.registerStudies)
                data["registerStudies"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    createTime?: Date;
    avatar?: string;
    email?: string;
    updateTime?: Date;
    password?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string;
    userStatus?: UserStatus;
    district?: District;
    province?: Province;
    certificate?: Certificate;
    ward?: Ward;
    answers?: Answers[];
    bills?: Bill[];
    blogs?: Blog[];
    commentBlogs?: CommentBlog[];
    confirmEmails?: ConfirmEmail[];
    courses?: Course[];
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];
    likeBlogs?: LikeBlog[];
    makeQuestions?: MakeQuestion[];
    notifications?: Notification[];
    permissions?: Permission[];
    refreshTokens?: RefreshToken[];
    registerStudies?: RegisterStudy[];
}

export enum UserStatus {
    Active = "Active",
}

export class District implements IDistrict {
    id?: number;
    provinceId?: number;
    name?: string;
    province?: Province;
    users?: User[];
    wards?: Ward[];

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provinceId = _data["provinceId"];
            this.name = _data["name"];
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
            if (Array.isArray(_data["wards"])) {
                this.wards = [] as any;
                for (let item of _data["wards"])
                    this.wards!.push(Ward.fromJS(item));
            }
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provinceId"] = this.provinceId;
        data["name"] = this.name;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.wards)) {
            data["wards"] = [];
            for (let item of this.wards)
                data["wards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDistrict {
    id?: number;
    provinceId?: number;
    name?: string;
    province?: Province;
    users?: User[];
    wards?: Ward[];
}

export class Province implements IProvince {
    id?: number;
    name?: string;
    districts?: District[];
    users?: User[];

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["districts"])) {
                this.districts = [] as any;
                for (let item of _data["districts"])
                    this.districts!.push(District.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.districts)) {
            data["districts"] = [];
            for (let item of this.districts)
                data["districts"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProvince {
    id?: number;
    name?: string;
    districts?: District[];
    users?: User[];
}

export class Ward implements IWard {
    id?: number;
    districtId?: number;
    name?: string;
    district?: District;
    users?: User[];

    constructor(data?: IWard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.name = _data["name"];
            this.district = _data["district"] ? District.fromJS(_data["district"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Ward {
        data = typeof data === 'object' ? data : {};
        let result = new Ward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["name"] = this.name;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWard {
    id?: number;
    districtId?: number;
    name?: string;
    district?: District;
    users?: User[];
}

export class Certificate implements ICertificate {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;
    certificateType?: CertificateType;
    users?: User[];

    constructor(data?: ICertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.certificateType = _data["certificateType"] ? CertificateType.fromJS(_data["certificateType"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateTypeId"] = this.certificateTypeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        data["certificateType"] = this.certificateType ? this.certificateType.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICertificate {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;
    certificateType?: CertificateType;
    users?: User[];
}

export class CertificateType implements ICertificateType {
    id?: number;
    name?: string;
    certificates?: Certificate[];

    constructor(data?: ICertificateType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["certificates"])) {
                this.certificates = [] as any;
                for (let item of _data["certificates"])
                    this.certificates!.push(Certificate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CertificateType {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.certificates)) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICertificateType {
    id?: number;
    name?: string;
    certificates?: Certificate[];
}

export class Answers implements IAnswers {
    id?: number;
    questionId?: number;
    userId?: number;
    answer?: string;
    createTime?: Date;
    updateTime?: Date;
    question?: MakeQuestion;
    user?: User;

    constructor(data?: IAnswers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.userId = _data["userId"];
            this.answer = _data["answer"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.question = _data["question"] ? MakeQuestion.fromJS(_data["question"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Answers {
        data = typeof data === 'object' ? data : {};
        let result = new Answers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["userId"] = this.userId;
        data["answer"] = this.answer;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAnswers {
    id?: number;
    questionId?: number;
    userId?: number;
    answer?: string;
    createTime?: Date;
    updateTime?: Date;
    question?: MakeQuestion;
    user?: User;
}

export class MakeQuestion implements IMakeQuestion {
    id?: number;
    userId?: number;
    subjectDetailId?: number;
    question?: string;
    numberOfAnswers?: number;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    subjectDetail?: SubjectDetail;
    answers?: Answers[];

    constructor(data?: IMakeQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.subjectDetailId = _data["subjectDetailId"];
            this.question = _data["question"];
            this.numberOfAnswers = _data["numberOfAnswers"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.subjectDetail = _data["subjectDetail"] ? SubjectDetail.fromJS(_data["subjectDetail"]) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MakeQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new MakeQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["subjectDetailId"] = this.subjectDetailId;
        data["question"] = this.question;
        data["numberOfAnswers"] = this.numberOfAnswers;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["subjectDetail"] = this.subjectDetail ? this.subjectDetail.toJSON() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMakeQuestion {
    id?: number;
    userId?: number;
    subjectDetailId?: number;
    question?: string;
    numberOfAnswers?: number;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    subjectDetail?: SubjectDetail;
    answers?: Answers[];
}

export class SubjectDetail implements ISubjectDetail {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;
    subject?: Subject;
    makeQuestions?: MakeQuestion[];
    practices?: Practice[];

    constructor(data?: ISubjectDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.name = _data["name"];
            this.isFinished = _data["isFinished"];
            this.linkVideo = _data["linkVideo"];
            this.isActive = _data["isActive"];
            this.subject = _data["subject"] ? Subject.fromJS(_data["subject"]) : <any>undefined;
            if (Array.isArray(_data["makeQuestions"])) {
                this.makeQuestions = [] as any;
                for (let item of _data["makeQuestions"])
                    this.makeQuestions!.push(MakeQuestion.fromJS(item));
            }
            if (Array.isArray(_data["practices"])) {
                this.practices = [] as any;
                for (let item of _data["practices"])
                    this.practices!.push(Practice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubjectDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["name"] = this.name;
        data["isFinished"] = this.isFinished;
        data["linkVideo"] = this.linkVideo;
        data["isActive"] = this.isActive;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        if (Array.isArray(this.makeQuestions)) {
            data["makeQuestions"] = [];
            for (let item of this.makeQuestions)
                data["makeQuestions"].push(item.toJSON());
        }
        if (Array.isArray(this.practices)) {
            data["practices"] = [];
            for (let item of this.practices)
                data["practices"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubjectDetail {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;
    subject?: Subject;
    makeQuestions?: MakeQuestion[];
    practices?: Practice[];
}

export class Subject implements ISubject {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
    courseSubjects?: CourseSubject[];
    learningProgresses?: LearningProgress[];
    registerStudies?: RegisterStudy[];
    subjectDetails?: SubjectDetail[];

    constructor(data?: ISubject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubject.fromJS(item));
            }
            if (Array.isArray(_data["learningProgresses"])) {
                this.learningProgresses = [] as any;
                for (let item of _data["learningProgresses"])
                    this.learningProgresses!.push(LearningProgress.fromJS(item));
            }
            if (Array.isArray(_data["registerStudies"])) {
                this.registerStudies = [] as any;
                for (let item of _data["registerStudies"])
                    this.registerStudies!.push(RegisterStudy.fromJS(item));
            }
            if (Array.isArray(_data["subjectDetails"])) {
                this.subjectDetails = [] as any;
                for (let item of _data["subjectDetails"])
                    this.subjectDetails!.push(SubjectDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Subject {
        data = typeof data === 'object' ? data : {};
        let result = new Subject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        if (Array.isArray(this.learningProgresses)) {
            data["learningProgresses"] = [];
            for (let item of this.learningProgresses)
                data["learningProgresses"].push(item.toJSON());
        }
        if (Array.isArray(this.registerStudies)) {
            data["registerStudies"] = [];
            for (let item of this.registerStudies)
                data["registerStudies"].push(item.toJSON());
        }
        if (Array.isArray(this.subjectDetails)) {
            data["subjectDetails"] = [];
            for (let item of this.subjectDetails)
                data["subjectDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubject {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
    courseSubjects?: CourseSubject[];
    learningProgresses?: LearningProgress[];
    registerStudies?: RegisterStudy[];
    subjectDetails?: SubjectDetail[];
}

export class CourseSubject implements ICourseSubject {
    id?: number;
    courseId?: number;
    subjectId?: number;
    course?: Course;
    subject?: Subject;

    constructor(data?: ICourseSubject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.subject = _data["subject"] ? Subject.fromJS(_data["subject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseSubject {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSubject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICourseSubject {
    id?: number;
    courseId?: number;
    subjectId?: number;
    course?: Course;
    subject?: Subject;
}

export class Course implements ICourse {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    creator?: User;
    bills?: Bill[];
    courseSubjects?: CourseSubject[];
    registerStudies?: RegisterStudy[];

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.creatorId = _data["creatorId"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            if (Array.isArray(_data["bills"])) {
                this.bills = [] as any;
                for (let item of _data["bills"])
                    this.bills!.push(Bill.fromJS(item));
            }
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubject.fromJS(item));
            }
            if (Array.isArray(_data["registerStudies"])) {
                this.registerStudies = [] as any;
                for (let item of _data["registerStudies"])
                    this.registerStudies!.push(RegisterStudy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["creatorId"] = this.creatorId;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.bills)) {
            data["bills"] = [];
            for (let item of this.bills)
                data["bills"].push(item.toJSON());
        }
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        if (Array.isArray(this.registerStudies)) {
            data["registerStudies"] = [];
            for (let item of this.registerStudies)
                data["registerStudies"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourse {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    creator?: User;
    bills?: Bill[];
    courseSubjects?: CourseSubject[];
    registerStudies?: RegisterStudy[];
}

export class Bill implements IBill {
    id?: number;
    userId?: number;
    courseId?: number;
    price?: number;
    tradingCode?: string;
    createTime?: Date;
    billStatusId?: number;
    user?: User;
    course?: Course;

    constructor(data?: IBill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.price = _data["price"];
            this.tradingCode = _data["tradingCode"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.billStatusId = _data["billStatusId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Bill {
        data = typeof data === 'object' ? data : {};
        let result = new Bill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["price"] = this.price;
        data["tradingCode"] = this.tradingCode;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["billStatusId"] = this.billStatusId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBill {
    id?: number;
    userId?: number;
    courseId?: number;
    price?: number;
    tradingCode?: string;
    createTime?: Date;
    billStatusId?: number;
    user?: User;
    course?: Course;
}

export class RegisterStudy implements IRegisterStudy {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;
    user?: User;
    course?: Course;
    currentSubject?: Subject;
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];

    constructor(data?: IRegisterStudy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.currentSubjectId = _data["currentSubjectId"];
            this.isFinished = _data["isFinished"];
            this.registerTime = _data["registerTime"] ? new Date(_data["registerTime"].toString()) : <any>undefined;
            this.percentComplete = _data["percentComplete"];
            this.doneTime = _data["doneTime"] ? new Date(_data["doneTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.currentSubject = _data["currentSubject"] ? Subject.fromJS(_data["currentSubject"]) : <any>undefined;
            if (Array.isArray(_data["doHomeworks"])) {
                this.doHomeworks = [] as any;
                for (let item of _data["doHomeworks"])
                    this.doHomeworks!.push(DoHomework.fromJS(item));
            }
            if (Array.isArray(_data["learningProgresses"])) {
                this.learningProgresses = [] as any;
                for (let item of _data["learningProgresses"])
                    this.learningProgresses!.push(LearningProgress.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegisterStudy {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterStudy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["currentSubjectId"] = this.currentSubjectId;
        data["isFinished"] = this.isFinished;
        data["registerTime"] = this.registerTime ? this.registerTime.toISOString() : <any>undefined;
        data["percentComplete"] = this.percentComplete;
        data["doneTime"] = this.doneTime ? this.doneTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["currentSubject"] = this.currentSubject ? this.currentSubject.toJSON() : <any>undefined;
        if (Array.isArray(this.doHomeworks)) {
            data["doHomeworks"] = [];
            for (let item of this.doHomeworks)
                data["doHomeworks"].push(item.toJSON());
        }
        if (Array.isArray(this.learningProgresses)) {
            data["learningProgresses"] = [];
            for (let item of this.learningProgresses)
                data["learningProgresses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegisterStudy {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;
    user?: User;
    course?: Course;
    currentSubject?: Subject;
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];
}

export class DoHomework implements IDoHomework {
    id?: number;
    practiceId?: number;
    userId?: number;
    homeworkStatus?: string;
    isFinished?: boolean;
    actualOutput?: string;
    doneTime?: Date;
    registerStudyId?: number;
    practice?: Practice;
    user?: User;
    registerStudy?: RegisterStudy;
    runTestCases?: RunTestCase[];

    constructor(data?: IDoHomework) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.practiceId = _data["practiceId"];
            this.userId = _data["userId"];
            this.homeworkStatus = _data["homeworkStatus"];
            this.isFinished = _data["isFinished"];
            this.actualOutput = _data["actualOutput"];
            this.doneTime = _data["doneTime"] ? new Date(_data["doneTime"].toString()) : <any>undefined;
            this.registerStudyId = _data["registerStudyId"];
            this.practice = _data["practice"] ? Practice.fromJS(_data["practice"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.registerStudy = _data["registerStudy"] ? RegisterStudy.fromJS(_data["registerStudy"]) : <any>undefined;
            if (Array.isArray(_data["runTestCases"])) {
                this.runTestCases = [] as any;
                for (let item of _data["runTestCases"])
                    this.runTestCases!.push(RunTestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DoHomework {
        data = typeof data === 'object' ? data : {};
        let result = new DoHomework();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["practiceId"] = this.practiceId;
        data["userId"] = this.userId;
        data["homeworkStatus"] = this.homeworkStatus;
        data["isFinished"] = this.isFinished;
        data["actualOutput"] = this.actualOutput;
        data["doneTime"] = this.doneTime ? this.doneTime.toISOString() : <any>undefined;
        data["registerStudyId"] = this.registerStudyId;
        data["practice"] = this.practice ? this.practice.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["registerStudy"] = this.registerStudy ? this.registerStudy.toJSON() : <any>undefined;
        if (Array.isArray(this.runTestCases)) {
            data["runTestCases"] = [];
            for (let item of this.runTestCases)
                data["runTestCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDoHomework {
    id?: number;
    practiceId?: number;
    userId?: number;
    homeworkStatus?: string;
    isFinished?: boolean;
    actualOutput?: string;
    doneTime?: Date;
    registerStudyId?: number;
    practice?: Practice;
    user?: User;
    registerStudy?: RegisterStudy;
    runTestCases?: RunTestCase[];
}

export class Practice implements IPractice {
    id?: number;
    subjectDetailId?: number;
    level?: string;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;
    subjectDetail?: SubjectDetail;
    programingLanguage?: ProgramingLanguage;
    doHomeworks?: DoHomework[];
    testCases?: TestCase[];

    constructor(data?: IPractice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectDetailId = _data["subjectDetailId"];
            this.level = _data["level"];
            this.practiceCode = _data["practiceCode"];
            this.title = _data["title"];
            this.topic = _data["topic"];
            this.expectOutput = _data["expectOutput"];
            this.languageProgrammingId = _data["languageProgrammingId"];
            this.isRequired = _data["isRequired"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.mediumScore = _data["mediumScore"];
            this.subjectDetail = _data["subjectDetail"] ? SubjectDetail.fromJS(_data["subjectDetail"]) : <any>undefined;
            this.programingLanguage = _data["programingLanguage"] ? ProgramingLanguage.fromJS(_data["programingLanguage"]) : <any>undefined;
            if (Array.isArray(_data["doHomeworks"])) {
                this.doHomeworks = [] as any;
                for (let item of _data["doHomeworks"])
                    this.doHomeworks!.push(DoHomework.fromJS(item));
            }
            if (Array.isArray(_data["testCases"])) {
                this.testCases = [] as any;
                for (let item of _data["testCases"])
                    this.testCases!.push(TestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Practice {
        data = typeof data === 'object' ? data : {};
        let result = new Practice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectDetailId"] = this.subjectDetailId;
        data["level"] = this.level;
        data["practiceCode"] = this.practiceCode;
        data["title"] = this.title;
        data["topic"] = this.topic;
        data["expectOutput"] = this.expectOutput;
        data["languageProgrammingId"] = this.languageProgrammingId;
        data["isRequired"] = this.isRequired;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["mediumScore"] = this.mediumScore;
        data["subjectDetail"] = this.subjectDetail ? this.subjectDetail.toJSON() : <any>undefined;
        data["programingLanguage"] = this.programingLanguage ? this.programingLanguage.toJSON() : <any>undefined;
        if (Array.isArray(this.doHomeworks)) {
            data["doHomeworks"] = [];
            for (let item of this.doHomeworks)
                data["doHomeworks"].push(item.toJSON());
        }
        if (Array.isArray(this.testCases)) {
            data["testCases"] = [];
            for (let item of this.testCases)
                data["testCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPractice {
    id?: number;
    subjectDetailId?: number;
    level?: string;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;
    subjectDetail?: SubjectDetail;
    programingLanguage?: ProgramingLanguage;
    doHomeworks?: DoHomework[];
    testCases?: TestCase[];
}

export class ProgramingLanguage implements IProgramingLanguage {
    id?: number;
    languageName?: string;
    practices?: Practice[];
    testCases?: TestCase[];

    constructor(data?: IProgramingLanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageName = _data["languageName"];
            if (Array.isArray(_data["practices"])) {
                this.practices = [] as any;
                for (let item of _data["practices"])
                    this.practices!.push(Practice.fromJS(item));
            }
            if (Array.isArray(_data["testCases"])) {
                this.testCases = [] as any;
                for (let item of _data["testCases"])
                    this.testCases!.push(TestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramingLanguage {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramingLanguage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageName"] = this.languageName;
        if (Array.isArray(this.practices)) {
            data["practices"] = [];
            for (let item of this.practices)
                data["practices"].push(item.toJSON());
        }
        if (Array.isArray(this.testCases)) {
            data["testCases"] = [];
            for (let item of this.testCases)
                data["testCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProgramingLanguage {
    id?: number;
    languageName?: string;
    practices?: Practice[];
    testCases?: TestCase[];
}

export class TestCase implements ITestCase {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;
    programingLanguage?: ProgramingLanguage;
    practice?: Practice;
    runTestCases?: RunTestCase[];

    constructor(data?: ITestCase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.input = _data["input"];
            this.output = _data["output"];
            this.programingLanguageId = _data["programingLanguageId"];
            this.practiceId = _data["practiceId"];
            this.programingLanguage = _data["programingLanguage"] ? ProgramingLanguage.fromJS(_data["programingLanguage"]) : <any>undefined;
            this.practice = _data["practice"] ? Practice.fromJS(_data["practice"]) : <any>undefined;
            if (Array.isArray(_data["runTestCases"])) {
                this.runTestCases = [] as any;
                for (let item of _data["runTestCases"])
                    this.runTestCases!.push(RunTestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TestCase {
        data = typeof data === 'object' ? data : {};
        let result = new TestCase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["input"] = this.input;
        data["output"] = this.output;
        data["programingLanguageId"] = this.programingLanguageId;
        data["practiceId"] = this.practiceId;
        data["programingLanguage"] = this.programingLanguage ? this.programingLanguage.toJSON() : <any>undefined;
        data["practice"] = this.practice ? this.practice.toJSON() : <any>undefined;
        if (Array.isArray(this.runTestCases)) {
            data["runTestCases"] = [];
            for (let item of this.runTestCases)
                data["runTestCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITestCase {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;
    programingLanguage?: ProgramingLanguage;
    practice?: Practice;
    runTestCases?: RunTestCase[];
}

export class RunTestCase implements IRunTestCase {
    id?: number;
    doHomeworkId?: number;
    testCaseId?: number;
    result?: string;
    runTime?: number;
    doHomework?: DoHomework;
    testCase?: TestCase;

    constructor(data?: IRunTestCase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.doHomeworkId = _data["doHomeworkId"];
            this.testCaseId = _data["testCaseId"];
            this.result = _data["result"];
            this.runTime = _data["runTime"];
            this.doHomework = _data["doHomework"] ? DoHomework.fromJS(_data["doHomework"]) : <any>undefined;
            this.testCase = _data["testCase"] ? TestCase.fromJS(_data["testCase"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RunTestCase {
        data = typeof data === 'object' ? data : {};
        let result = new RunTestCase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["doHomeworkId"] = this.doHomeworkId;
        data["testCaseId"] = this.testCaseId;
        data["result"] = this.result;
        data["runTime"] = this.runTime;
        data["doHomework"] = this.doHomework ? this.doHomework.toJSON() : <any>undefined;
        data["testCase"] = this.testCase ? this.testCase.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRunTestCase {
    id?: number;
    doHomeworkId?: number;
    testCaseId?: number;
    result?: string;
    runTime?: number;
    doHomework?: DoHomework;
    testCase?: TestCase;
}

export class LearningProgress implements ILearningProgress {
    id?: number;
    userId?: number;
    registerStudyId?: number;
    currentSubjectId?: number;
    user?: User;
    registerStudy?: RegisterStudy;
    currentSubject?: Subject;

    constructor(data?: ILearningProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.registerStudyId = _data["registerStudyId"];
            this.currentSubjectId = _data["currentSubjectId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.registerStudy = _data["registerStudy"] ? RegisterStudy.fromJS(_data["registerStudy"]) : <any>undefined;
            this.currentSubject = _data["currentSubject"] ? Subject.fromJS(_data["currentSubject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LearningProgress {
        data = typeof data === 'object' ? data : {};
        let result = new LearningProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["registerStudyId"] = this.registerStudyId;
        data["currentSubjectId"] = this.currentSubjectId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["registerStudy"] = this.registerStudy ? this.registerStudy.toJSON() : <any>undefined;
        data["currentSubject"] = this.currentSubject ? this.currentSubject.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILearningProgress {
    id?: number;
    userId?: number;
    registerStudyId?: number;
    currentSubjectId?: number;
    user?: User;
    registerStudy?: RegisterStudy;
    currentSubject?: Subject;
}

export class Blog implements IBlog {
    id?: number;
    creatorId?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlog[];
    likeBlogs?: LikeBlog[];

    constructor(data?: IBlog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorId = _data["creatorId"];
            this.content = _data["content"];
            this.title = _data["title"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            if (Array.isArray(_data["commentBlogs"])) {
                this.commentBlogs = [] as any;
                for (let item of _data["commentBlogs"])
                    this.commentBlogs!.push(CommentBlog.fromJS(item));
            }
            if (Array.isArray(_data["likeBlogs"])) {
                this.likeBlogs = [] as any;
                for (let item of _data["likeBlogs"])
                    this.likeBlogs!.push(LikeBlog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Blog {
        data = typeof data === 'object' ? data : {};
        let result = new Blog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorId"] = this.creatorId;
        data["content"] = this.content;
        data["title"] = this.title;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.commentBlogs)) {
            data["commentBlogs"] = [];
            for (let item of this.commentBlogs)
                data["commentBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.likeBlogs)) {
            data["likeBlogs"] = [];
            for (let item of this.likeBlogs)
                data["likeBlogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlog {
    id?: number;
    creatorId?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlog[];
    likeBlogs?: LikeBlog[];
}

export class CommentBlog implements ICommentBlog {
    id?: number;
    blogId?: number;
    userId?: number;
    content?: string;
    edited?: boolean;
    blog?: Blog;
    user?: User;

    constructor(data?: ICommentBlog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blogId = _data["blogId"];
            this.userId = _data["userId"];
            this.content = _data["content"];
            this.edited = _data["edited"];
            this.blog = _data["blog"] ? Blog.fromJS(_data["blog"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentBlog {
        data = typeof data === 'object' ? data : {};
        let result = new CommentBlog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blogId"] = this.blogId;
        data["userId"] = this.userId;
        data["content"] = this.content;
        data["edited"] = this.edited;
        data["blog"] = this.blog ? this.blog.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentBlog {
    id?: number;
    blogId?: number;
    userId?: number;
    content?: string;
    edited?: boolean;
    blog?: Blog;
    user?: User;
}

export class LikeBlog implements ILikeBlog {
    id?: number;
    userId?: number;
    blogId?: number;
    unlike?: boolean;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    blog?: Blog;

    constructor(data?: ILikeBlog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.blogId = _data["blogId"];
            this.unlike = _data["unlike"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.blog = _data["blog"] ? Blog.fromJS(_data["blog"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LikeBlog {
        data = typeof data === 'object' ? data : {};
        let result = new LikeBlog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["blogId"] = this.blogId;
        data["unlike"] = this.unlike;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["blog"] = this.blog ? this.blog.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILikeBlog {
    id?: number;
    userId?: number;
    blogId?: number;
    unlike?: boolean;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    blog?: Blog;
}

export class ConfirmEmail implements IConfirmEmail {
    id?: number;
    confirmCode?: string;
    expiryTime?: Date;
    userId?: number;
    isConfirm?: boolean;
    user?: User;

    constructor(data?: IConfirmEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.confirmCode = _data["confirmCode"];
            this.expiryTime = _data["expiryTime"] ? new Date(_data["expiryTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isConfirm = _data["isConfirm"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConfirmEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["confirmCode"] = this.confirmCode;
        data["expiryTime"] = this.expiryTime ? this.expiryTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isConfirm"] = this.isConfirm;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConfirmEmail {
    id?: number;
    confirmCode?: string;
    expiryTime?: Date;
    userId?: number;
    isConfirm?: boolean;
    user?: User;
}

export class Notification implements INotification {
    id?: number;
    userId?: number;
    image?: string;
    content?: string;
    link?: string;
    isSeen?: boolean;
    createTime?: Date;
    user?: User;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.image = _data["image"];
            this.content = _data["content"];
            this.link = _data["link"];
            this.isSeen = _data["isSeen"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["image"] = this.image;
        data["content"] = this.content;
        data["link"] = this.link;
        data["isSeen"] = this.isSeen;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotification {
    id?: number;
    userId?: number;
    image?: string;
    content?: string;
    link?: string;
    isSeen?: boolean;
    createTime?: Date;
    user?: User;
}

export class Permission implements IPermission {
    id?: number;
    userId?: number;
    roleId?: number;
    user?: User;
    role?: Role;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPermission {
    id?: number;
    userId?: number;
    roleId?: number;
    user?: User;
    role?: Role;
}

export class Role implements IRole {
    id?: number;
    roleCode?: string;
    roleName?: string;
    permissions?: Permission[];

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleCode = _data["roleCode"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleCode"] = this.roleCode;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRole {
    id?: number;
    roleCode?: string;
    roleName?: string;
    permissions?: Permission[];
}

export class RefreshToken implements IRefreshToken {
    id?: number;
    token?: string;
    expiryTime?: Date;
    userId?: number;
    user?: User;

    constructor(data?: IRefreshToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.expiryTime = _data["expiryTime"] ? new Date(_data["expiryTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RefreshToken {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["expiryTime"] = this.expiryTime ? this.expiryTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRefreshToken {
    id?: number;
    token?: string;
    expiryTime?: Date;
    userId?: number;
    user?: User;
}

export class Result implements IResult {
    status?: ResultStatus;
    error?: string | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["error"] = this.error;
        return data;
    }
}

export interface IResult {
    status?: ResultStatus;
    error?: string | undefined;
}

export enum ResultStatus {
    Succeess = "Succeess",
    Failure = "Failure",
    NotFound = "NotFound",
    Forbidden = "Forbidden",
}

export class BlogCreate implements IBlogCreate {
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;

    constructor(data?: IBlogCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.title = _data["title"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BlogCreate {
        data = typeof data === 'object' ? data : {};
        let result = new BlogCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["title"] = this.title;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBlogCreate {
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
}

export class BlogUpdate implements IBlogUpdate {
    id?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;

    constructor(data?: IBlogUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.title = _data["title"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BlogUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new BlogUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["title"] = this.title;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBlogUpdate {
    id?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
}

export class PagingModelOfCourseMapping implements IPagingModelOfCourseMapping {
    items?: CourseMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfCourseMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfCourseMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfCourseMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfCourseMapping {
    items?: CourseMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CourseMapping implements ICourseMapping {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];

    constructor(data?: ICourseMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.creatorId = _data["creatorId"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CourseMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["creatorId"] = this.creatorId;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseMapping {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];
}

export class CourseSubjectMapping implements ICourseSubjectMapping {
    id?: number;
    courseId?: number;
    subjectId?: number;
    subject?: SubjectMapping | undefined;

    constructor(data?: ICourseSubjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.subject = _data["subject"] ? SubjectMapping.fromJS(_data["subject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseSubjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSubjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICourseSubjectMapping {
    id?: number;
    courseId?: number;
    subjectId?: number;
    subject?: SubjectMapping | undefined;
}

export class SubjectMapping implements ISubjectMapping {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;

    constructor(data?: ISubjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectMapping {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
}

export class CourseCreate implements ICourseCreate {
    name?: string;
    introduce?: string;
    imageCourse?: string;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];

    constructor(data?: ICourseCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseCreate {
        data = typeof data === 'object' ? data : {};
        let result = new CourseCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseCreate {
    name?: string;
    introduce?: string;
    imageCourse?: string;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];
}

export class CourseUpdate implements ICourseUpdate {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];

    constructor(data?: ICourseUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.creatorId = _data["creatorId"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CourseUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["creatorId"] = this.creatorId;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseUpdate {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];
}

export class PagingModelOfSubjectMapping implements IPagingModelOfSubjectMapping {
    items?: SubjectMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfSubjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubjectMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfSubjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfSubjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfSubjectMapping {
    items?: SubjectMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SubjectCreate implements ISubjectCreate {
    name!: string;
    symbol!: string;
    isActive?: boolean;

    constructor(data?: ISubjectCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectCreate {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectCreate {
    name: string;
    symbol: string;
    isActive?: boolean;
}

export class SubjectUpdate implements ISubjectUpdate {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;

    constructor(data?: ISubjectUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectUpdate {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}