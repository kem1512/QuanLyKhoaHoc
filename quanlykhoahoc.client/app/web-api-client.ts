//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import followIfLoginRedirect from '../components/api-authorization/followIfLoginRedirect';
import store from "../lib/store"

export class AccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    userInfo(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserInfo(_response);
        });
    }

    protected processUserInfo(response: Response): Promise<FileResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    userInfoUpdate(entity: UserInfoUpdate): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserInfoUpdate(_response);
        });
    }

    protected processUserInfoUpdate(response: Response): Promise<FileResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(request: LoginRequest): Promise<TokenRequest> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<TokenRequest> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenRequest>(null as any);
    }

    logout(token: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/logout?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    register(request: RegisterRequest): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<FileResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    refresh(refreshToken: string | undefined): Promise<TokenRequest> {
        let url_ = this.baseUrl + "/api/Auth/refresh?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<TokenRequest> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenRequest>(null as any);
    }

    confirmEmail(token: string | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Auth/ConfirmEmail?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<FileResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    sendConfirmEmail(email: string | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Auth/SendConfirmEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/octet-stream",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendConfirmEmail(_response);
        });
    }

    protected processSendConfirmEmail(response: Response): Promise<FileResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class BlogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfBlogMapping> {
        let url_ = this.baseUrl + "/api/Blog?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfBlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfBlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfBlogMapping>(null as any);
    }

    createEntity(entity: BlogCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Blog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<BlogMapping> {
        let url_ = this.baseUrl + "/api/Blog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<BlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlogMapping>(null as any);
    }

    updateEntity(id: number, entity: BlogUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Blog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Blog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class CertificateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfCertificateMapping> {
        let url_ = this.baseUrl + "/api/Certificate?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfCertificateMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfCertificateMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfCertificateMapping>(null as any);
    }

    createEntity(entity: CertificateCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Certificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<CertificateMapping> {
        let url_ = this.baseUrl + "/api/Certificate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<CertificateMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificateMapping>(null as any);
    }

    updateEntity(id: number, entity: CertificateUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Certificate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Certificate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class CertificateTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfCertificateTypeMapping> {
        let url_ = this.baseUrl + "/api/CertificateType?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfCertificateTypeMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfCertificateTypeMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfCertificateTypeMapping>(null as any);
    }

    createEntity(entity: CertificateTypeCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/CertificateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<CertificateTypeMapping> {
        let url_ = this.baseUrl + "/api/CertificateType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<CertificateTypeMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateTypeMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificateTypeMapping>(null as any);
    }

    updateEntity(id: number, entity: CertificateTypeUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/CertificateType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/CertificateType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class CommentBlogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(parentId: number | null | undefined, blogId: number | null | undefined, filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfCommentBlogMapping> {
        let url_ = this.baseUrl + "/api/CommentBlog?";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (blogId !== undefined && blogId !== null)
            url_ += "BlogId=" + encodeURIComponent("" + blogId) + "&";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfCommentBlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfCommentBlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfCommentBlogMapping>(null as any);
    }

    createEntity(entity: CommentBlogCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/CommentBlog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<CommentBlogMapping> {
        let url_ = this.baseUrl + "/api/CommentBlog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<CommentBlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentBlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommentBlogMapping>(null as any);
    }

    updateEntity(id: number, entity: CommentBlogUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/CommentBlog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/CommentBlog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class CourseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfCourseMapping> {
        let url_ = this.baseUrl + "/api/Course?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfCourseMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfCourseMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfCourseMapping>(null as any);
    }

    createEntity(entity: CourseCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<CourseMapping> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<CourseMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseMapping>(null as any);
    }

    updateEntity(id: number, entity: CourseUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class DistrictClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(provinceId: number | null | undefined, filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfDistrictMapping> {
        let url_ = this.baseUrl + "/api/District?";
        if (provinceId !== undefined && provinceId !== null)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfDistrictMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfDistrictMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfDistrictMapping>(null as any);
    }

    createEntity(entity: DistrictCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/District";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<DistrictMapping> {
        let url_ = this.baseUrl + "/api/District/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<DistrictMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistrictMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DistrictMapping>(null as any);
    }

    updateEntity(id: number, entity: DistrictUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/District/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/District/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class LikeBlogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfLikeBlogMapping> {
        let url_ = this.baseUrl + "/api/LikeBlog?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfLikeBlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfLikeBlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfLikeBlogMapping>(null as any);
    }

    createEntity(entity: LikeBlogCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/LikeBlog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<LikeBlogMapping> {
        let url_ = this.baseUrl + "/api/LikeBlog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<LikeBlogMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeBlogMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LikeBlogMapping>(null as any);
    }

    updateEntity(id: number, entity: LikeBlogUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/LikeBlog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/LikeBlog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class PracticeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfPracticeMapping> {
        let url_ = this.baseUrl + "/api/Practice?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfPracticeMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfPracticeMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfPracticeMapping>(null as any);
    }

    createEntity(entity: PracticeCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Practice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<PracticeMapping> {
        let url_ = this.baseUrl + "/api/Practice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<PracticeMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PracticeMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PracticeMapping>(null as any);
    }

    updateEntity(id: number, entity: PracticeUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Practice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Practice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class ProgramingLanguageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfProgramingLanguageMapping> {
        let url_ = this.baseUrl + "/api/ProgramingLanguage?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfProgramingLanguageMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfProgramingLanguageMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfProgramingLanguageMapping>(null as any);
    }

    createEntity(entity: ProgramingLanguageCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/ProgramingLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<ProgramingLanguageMapping> {
        let url_ = this.baseUrl + "/api/ProgramingLanguage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<ProgramingLanguageMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramingLanguageMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramingLanguageMapping>(null as any);
    }

    updateEntity(id: number, entity: ProgramingLanguageUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/ProgramingLanguage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/ProgramingLanguage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class ProvinceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfProvinceMapping> {
        let url_ = this.baseUrl + "/api/Province?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfProvinceMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfProvinceMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfProvinceMapping>(null as any);
    }

    createEntity(entity: ProvinceCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Province";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<ProvinceMapping> {
        let url_ = this.baseUrl + "/api/Province/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<ProvinceMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinceMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProvinceMapping>(null as any);
    }

    updateEntity(id: number, entity: ProvinceUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Province/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Province/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class RegisterStudyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfRegisterStudyMapping> {
        let url_ = this.baseUrl + "/api/RegisterStudy?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfRegisterStudyMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfRegisterStudyMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfRegisterStudyMapping>(null as any);
    }

    createEntity(entity: RegisterStudyCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/RegisterStudy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<RegisterStudyMapping> {
        let url_ = this.baseUrl + "/api/RegisterStudy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<RegisterStudyMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterStudyMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisterStudyMapping>(null as any);
    }

    updateEntity(id: number, entity: RegisterStudyUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/RegisterStudy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/RegisterStudy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class RoleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfRoleMapping> {
        let url_ = this.baseUrl + "/api/Role?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfRoleMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfRoleMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfRoleMapping>(null as any);
    }

    createEntity(entity: RoleCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<RoleMapping> {
        let url_ = this.baseUrl + "/api/Role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<RoleMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleMapping>(null as any);
    }

    updateEntity(id: number, entity: RoleUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class StatisticalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    check(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Statistical";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheck(_response);
        });
    }

    protected processCheck(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class SubjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfSubjectMapping> {
        let url_ = this.baseUrl + "/api/Subject?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfSubjectMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfSubjectMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfSubjectMapping>(null as any);
    }

    createEntity(entity: SubjectCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Subject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<SubjectMapping> {
        let url_ = this.baseUrl + "/api/Subject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<SubjectMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubjectMapping>(null as any);
    }

    updateEntity(id: number, entity: SubjectUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Subject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Subject/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class SubjectDetailClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfSubjectDetailMapping> {
        let url_ = this.baseUrl + "/api/SubjectDetail?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfSubjectDetailMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfSubjectDetailMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfSubjectDetailMapping>(null as any);
    }

    createEntity(entity: SubjectDetailCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/SubjectDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<SubjectDetailMapping> {
        let url_ = this.baseUrl + "/api/SubjectDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<SubjectDetailMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubjectDetailMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubjectDetailMapping>(null as any);
    }

    updateEntity(id: number, entity: SubjectDetailUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/SubjectDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/SubjectDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class TestCaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfTestCaseMapping> {
        let url_ = this.baseUrl + "/api/TestCase?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfTestCaseMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfTestCaseMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfTestCaseMapping>(null as any);
    }

    createEntity(entity: TestCaseCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/TestCase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<TestCaseMapping> {
        let url_ = this.baseUrl + "/api/TestCase/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<TestCaseMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestCaseMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TestCaseMapping>(null as any);
    }

    updateEntity(id: number, entity: TestCaseUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/TestCase/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/TestCase/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfUserMapping> {
        let url_ = this.baseUrl + "/api/User?";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfUserMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfUserMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfUserMapping>(null as any);
    }

    createEntity(entity: UserCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<UserMapping> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<UserMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserMapping>(null as any);
    }

    updateEntity(id: number, entity: UserUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class WardClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (typeof window !== 'undefined' ? window : { fetch }) as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEntities(districtId: number | null | undefined, filters: string | null | undefined, sorts: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Promise<PagingModelOfWardMapping> {
        let url_ = this.baseUrl + "/api/Ward?";
        if (districtId !== undefined && districtId !== null)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (filters !== undefined && filters !== null)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts !== undefined && sorts !== null)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntities(_response);
        });
    }

    protected processGetEntities(response: Response): Promise<PagingModelOfWardMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingModelOfWardMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagingModelOfWardMapping>(null as any);
    }

    createEntity(entity: WardCreate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Ward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntity(_response);
        });
    }

    protected processCreateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEntity(id: number): Promise<WardMapping> {
        let url_ = this.baseUrl + "/api/Ward/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntity(_response);
        });
    }

    protected processGetEntity(response: Response): Promise<WardMapping> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WardMapping.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WardMapping>(null as any);
    }

    updateEntity(id: number, entity: WardUpdate): Promise<Result> {
        let url_ = this.baseUrl + "/api/Ward/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntity(_response);
        });
    }

    protected processUpdateEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEntity(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/Ward/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${store.getState().auth.accessToken}`
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntity(_response);
        });
    }

    protected processDeleteEntity(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class UserInfoUpdate implements IUserInfoUpdate {
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    avatar?: string | undefined;
    fullName?: string;
    dateOfBirth?: Date;
    address?: string | undefined;

    constructor(data?: IUserInfoUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.certificateId = _data["certificateId"];
            this.wardId = _data["wardId"];
            this.username = _data["username"];
            this.avatar = _data["avatar"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): UserInfoUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["certificateId"] = this.certificateId;
        data["wardId"] = this.wardId;
        data["username"] = this.username;
        data["avatar"] = this.avatar;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["address"] = this.address;
        return data;
    }
}

export interface IUserInfoUpdate {
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    avatar?: string | undefined;
    fullName?: string;
    dateOfBirth?: Date;
    address?: string | undefined;
}

export class TokenRequest implements ITokenRequest {
    accessToken?: string;
    refreshToken?: string;

    constructor(data?: ITokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): TokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ITokenRequest {
    accessToken?: string;
    refreshToken?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
}

export class PagingModelOfBlogMapping implements IPagingModelOfBlogMapping {
    items?: BlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlogMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfBlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfBlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfBlogMapping {
    items?: BlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class BlogMapping implements IBlogMapping {
    id?: number;
    content?: string;
    image?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlogMapping[];
    likeBlogs?: LikeBlog[];

    constructor(data?: IBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.image = _data["image"];
            this.title = _data["title"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            if (Array.isArray(_data["commentBlogs"])) {
                this.commentBlogs = [] as any;
                for (let item of _data["commentBlogs"])
                    this.commentBlogs!.push(CommentBlogMapping.fromJS(item));
            }
            if (Array.isArray(_data["likeBlogs"])) {
                this.likeBlogs = [] as any;
                for (let item of _data["likeBlogs"])
                    this.likeBlogs!.push(LikeBlog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new BlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["image"] = this.image;
        data["title"] = this.title;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.commentBlogs)) {
            data["commentBlogs"] = [];
            for (let item of this.commentBlogs)
                data["commentBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.likeBlogs)) {
            data["likeBlogs"] = [];
            for (let item of this.likeBlogs)
                data["likeBlogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogMapping {
    id?: number;
    content?: string;
    image?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlogMapping[];
    likeBlogs?: LikeBlog[];
}

export class User implements IUser {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    createTime?: Date;
    avatar?: string | undefined;
    email?: string;
    updateTime?: Date;
    password?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    userStatus?: UserStatus;
    district?: District;
    province?: Province;
    certificate?: Certificate;
    ward?: Ward;
    answers?: Answers[];
    bills?: Bill[];
    blogs?: Blog[];
    commentBlogs?: CommentBlog[];
    confirmEmails?: ConfirmEmail[];
    courses?: Course[];
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];
    likeBlogs?: LikeBlog[];
    makeQuestions?: MakeQuestion[];
    notifications?: Notification[];
    permissions?: Permission[];
    refreshTokens?: RefreshToken[];
    registerStudies?: RegisterStudy[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.certificateId = _data["certificateId"];
            this.wardId = _data["wardId"];
            this.username = _data["username"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.email = _data["email"];
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.address = _data["address"];
            this.userStatus = _data["userStatus"];
            this.district = _data["district"] ? District.fromJS(_data["district"]) : <any>undefined;
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : <any>undefined;
            this.certificate = _data["certificate"] ? Certificate.fromJS(_data["certificate"]) : <any>undefined;
            this.ward = _data["ward"] ? Ward.fromJS(_data["ward"]) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answers.fromJS(item));
            }
            if (Array.isArray(_data["bills"])) {
                this.bills = [] as any;
                for (let item of _data["bills"])
                    this.bills!.push(Bill.fromJS(item));
            }
            if (Array.isArray(_data["blogs"])) {
                this.blogs = [] as any;
                for (let item of _data["blogs"])
                    this.blogs!.push(Blog.fromJS(item));
            }
            if (Array.isArray(_data["commentBlogs"])) {
                this.commentBlogs = [] as any;
                for (let item of _data["commentBlogs"])
                    this.commentBlogs!.push(CommentBlog.fromJS(item));
            }
            if (Array.isArray(_data["confirmEmails"])) {
                this.confirmEmails = [] as any;
                for (let item of _data["confirmEmails"])
                    this.confirmEmails!.push(ConfirmEmail.fromJS(item));
            }
            if (Array.isArray(_data["courses"])) {
                this.courses = [] as any;
                for (let item of _data["courses"])
                    this.courses!.push(Course.fromJS(item));
            }
            if (Array.isArray(_data["doHomeworks"])) {
                this.doHomeworks = [] as any;
                for (let item of _data["doHomeworks"])
                    this.doHomeworks!.push(DoHomework.fromJS(item));
            }
            if (Array.isArray(_data["learningProgresses"])) {
                this.learningProgresses = [] as any;
                for (let item of _data["learningProgresses"])
                    this.learningProgresses!.push(LearningProgress.fromJS(item));
            }
            if (Array.isArray(_data["likeBlogs"])) {
                this.likeBlogs = [] as any;
                for (let item of _data["likeBlogs"])
                    this.likeBlogs!.push(LikeBlog.fromJS(item));
            }
            if (Array.isArray(_data["makeQuestions"])) {
                this.makeQuestions = [] as any;
                for (let item of _data["makeQuestions"])
                    this.makeQuestions!.push(MakeQuestion.fromJS(item));
            }
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(Notification.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
            if (Array.isArray(_data["refreshTokens"])) {
                this.refreshTokens = [] as any;
                for (let item of _data["refreshTokens"])
                    this.refreshTokens!.push(RefreshToken.fromJS(item));
            }
            if (Array.isArray(_data["registerStudies"])) {
                this.registerStudies = [] as any;
                for (let item of _data["registerStudies"])
                    this.registerStudies!.push(RegisterStudy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["certificateId"] = this.certificateId;
        data["wardId"] = this.wardId;
        data["username"] = this.username;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["email"] = this.email;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["address"] = this.address;
        data["userStatus"] = this.userStatus;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["certificate"] = this.certificate ? this.certificate.toJSON() : <any>undefined;
        data["ward"] = this.ward ? this.ward.toJSON() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.bills)) {
            data["bills"] = [];
            for (let item of this.bills)
                data["bills"].push(item.toJSON());
        }
        if (Array.isArray(this.blogs)) {
            data["blogs"] = [];
            for (let item of this.blogs)
                data["blogs"].push(item.toJSON());
        }
        if (Array.isArray(this.commentBlogs)) {
            data["commentBlogs"] = [];
            for (let item of this.commentBlogs)
                data["commentBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.confirmEmails)) {
            data["confirmEmails"] = [];
            for (let item of this.confirmEmails)
                data["confirmEmails"].push(item.toJSON());
        }
        if (Array.isArray(this.courses)) {
            data["courses"] = [];
            for (let item of this.courses)
                data["courses"].push(item.toJSON());
        }
        if (Array.isArray(this.doHomeworks)) {
            data["doHomeworks"] = [];
            for (let item of this.doHomeworks)
                data["doHomeworks"].push(item.toJSON());
        }
        if (Array.isArray(this.learningProgresses)) {
            data["learningProgresses"] = [];
            for (let item of this.learningProgresses)
                data["learningProgresses"].push(item.toJSON());
        }
        if (Array.isArray(this.likeBlogs)) {
            data["likeBlogs"] = [];
            for (let item of this.likeBlogs)
                data["likeBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.makeQuestions)) {
            data["makeQuestions"] = [];
            for (let item of this.makeQuestions)
                data["makeQuestions"].push(item.toJSON());
        }
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.refreshTokens)) {
            data["refreshTokens"] = [];
            for (let item of this.refreshTokens)
                data["refreshTokens"].push(item.toJSON());
        }
        if (Array.isArray(this.registerStudies)) {
            data["registerStudies"] = [];
            for (let item of this.registerStudies)
                data["registerStudies"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    createTime?: Date;
    avatar?: string | undefined;
    email?: string;
    updateTime?: Date;
    password?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    userStatus?: UserStatus;
    district?: District;
    province?: Province;
    certificate?: Certificate;
    ward?: Ward;
    answers?: Answers[];
    bills?: Bill[];
    blogs?: Blog[];
    commentBlogs?: CommentBlog[];
    confirmEmails?: ConfirmEmail[];
    courses?: Course[];
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];
    likeBlogs?: LikeBlog[];
    makeQuestions?: MakeQuestion[];
    notifications?: Notification[];
    permissions?: Permission[];
    refreshTokens?: RefreshToken[];
    registerStudies?: RegisterStudy[];
}

export enum UserStatus {
    Active = "Active",
    Inactive = "Inactive",
    Banned = "Banned",
    Pending = "Pending",
}

export class District implements IDistrict {
    id?: number;
    provinceId?: number;
    name?: string;
    province?: Province;
    users?: User[];
    wards?: Ward[];

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provinceId = _data["provinceId"];
            this.name = _data["name"];
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
            if (Array.isArray(_data["wards"])) {
                this.wards = [] as any;
                for (let item of _data["wards"])
                    this.wards!.push(Ward.fromJS(item));
            }
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provinceId"] = this.provinceId;
        data["name"] = this.name;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (Array.isArray(this.wards)) {
            data["wards"] = [];
            for (let item of this.wards)
                data["wards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDistrict {
    id?: number;
    provinceId?: number;
    name?: string;
    province?: Province;
    users?: User[];
    wards?: Ward[];
}

export class Province implements IProvince {
    id?: number;
    name?: string;
    districts?: District[];
    users?: User[];

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["districts"])) {
                this.districts = [] as any;
                for (let item of _data["districts"])
                    this.districts!.push(District.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.districts)) {
            data["districts"] = [];
            for (let item of this.districts)
                data["districts"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProvince {
    id?: number;
    name?: string;
    districts?: District[];
    users?: User[];
}

export class Ward implements IWard {
    id?: number;
    districtId?: number;
    name?: string;
    district?: District;
    users?: User[];

    constructor(data?: IWard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.name = _data["name"];
            this.district = _data["district"] ? District.fromJS(_data["district"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Ward {
        data = typeof data === 'object' ? data : {};
        let result = new Ward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["name"] = this.name;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWard {
    id?: number;
    districtId?: number;
    name?: string;
    district?: District;
    users?: User[];
}

export class Certificate implements ICertificate {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;
    certificateType?: CertificateType;
    users?: User[];

    constructor(data?: ICertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.certificateType = _data["certificateType"] ? CertificateType.fromJS(_data["certificateType"]) : <any>undefined;
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateTypeId"] = this.certificateTypeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        data["certificateType"] = this.certificateType ? this.certificateType.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICertificate {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;
    certificateType?: CertificateType;
    users?: User[];
}

export class CertificateType implements ICertificateType {
    id?: number;
    name?: string;
    certificates?: Certificate[];

    constructor(data?: ICertificateType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["certificates"])) {
                this.certificates = [] as any;
                for (let item of _data["certificates"])
                    this.certificates!.push(Certificate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CertificateType {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.certificates)) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICertificateType {
    id?: number;
    name?: string;
    certificates?: Certificate[];
}

export class Answers implements IAnswers {
    id?: number;
    questionId?: number;
    userId?: number;
    answer?: string;
    createTime?: Date;
    updateTime?: Date;
    question?: MakeQuestion;
    user?: User;

    constructor(data?: IAnswers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.userId = _data["userId"];
            this.answer = _data["answer"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.question = _data["question"] ? MakeQuestion.fromJS(_data["question"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Answers {
        data = typeof data === 'object' ? data : {};
        let result = new Answers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["userId"] = this.userId;
        data["answer"] = this.answer;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAnswers {
    id?: number;
    questionId?: number;
    userId?: number;
    answer?: string;
    createTime?: Date;
    updateTime?: Date;
    question?: MakeQuestion;
    user?: User;
}

export class MakeQuestion implements IMakeQuestion {
    id?: number;
    userId?: number;
    subjectDetailId?: number;
    question?: string;
    numberOfAnswers?: number;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    subjectDetail?: SubjectDetail;
    answers?: Answers[];

    constructor(data?: IMakeQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.subjectDetailId = _data["subjectDetailId"];
            this.question = _data["question"];
            this.numberOfAnswers = _data["numberOfAnswers"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.subjectDetail = _data["subjectDetail"] ? SubjectDetail.fromJS(_data["subjectDetail"]) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MakeQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new MakeQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["subjectDetailId"] = this.subjectDetailId;
        data["question"] = this.question;
        data["numberOfAnswers"] = this.numberOfAnswers;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["subjectDetail"] = this.subjectDetail ? this.subjectDetail.toJSON() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMakeQuestion {
    id?: number;
    userId?: number;
    subjectDetailId?: number;
    question?: string;
    numberOfAnswers?: number;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    subjectDetail?: SubjectDetail;
    answers?: Answers[];
}

export class SubjectDetail implements ISubjectDetail {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;
    subject?: Subject;
    makeQuestions?: MakeQuestion[];
    practices?: Practice[];

    constructor(data?: ISubjectDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.name = _data["name"];
            this.isFinished = _data["isFinished"];
            this.linkVideo = _data["linkVideo"];
            this.isActive = _data["isActive"];
            this.subject = _data["subject"] ? Subject.fromJS(_data["subject"]) : <any>undefined;
            if (Array.isArray(_data["makeQuestions"])) {
                this.makeQuestions = [] as any;
                for (let item of _data["makeQuestions"])
                    this.makeQuestions!.push(MakeQuestion.fromJS(item));
            }
            if (Array.isArray(_data["practices"])) {
                this.practices = [] as any;
                for (let item of _data["practices"])
                    this.practices!.push(Practice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubjectDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["name"] = this.name;
        data["isFinished"] = this.isFinished;
        data["linkVideo"] = this.linkVideo;
        data["isActive"] = this.isActive;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        if (Array.isArray(this.makeQuestions)) {
            data["makeQuestions"] = [];
            for (let item of this.makeQuestions)
                data["makeQuestions"].push(item.toJSON());
        }
        if (Array.isArray(this.practices)) {
            data["practices"] = [];
            for (let item of this.practices)
                data["practices"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubjectDetail {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;
    subject?: Subject;
    makeQuestions?: MakeQuestion[];
    practices?: Practice[];
}

export class Subject implements ISubject {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
    courseSubjects?: CourseSubject[];
    learningProgresses?: LearningProgress[];
    registerStudies?: RegisterStudy[];
    subjectDetails?: SubjectDetail[];

    constructor(data?: ISubject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubject.fromJS(item));
            }
            if (Array.isArray(_data["learningProgresses"])) {
                this.learningProgresses = [] as any;
                for (let item of _data["learningProgresses"])
                    this.learningProgresses!.push(LearningProgress.fromJS(item));
            }
            if (Array.isArray(_data["registerStudies"])) {
                this.registerStudies = [] as any;
                for (let item of _data["registerStudies"])
                    this.registerStudies!.push(RegisterStudy.fromJS(item));
            }
            if (Array.isArray(_data["subjectDetails"])) {
                this.subjectDetails = [] as any;
                for (let item of _data["subjectDetails"])
                    this.subjectDetails!.push(SubjectDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Subject {
        data = typeof data === 'object' ? data : {};
        let result = new Subject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        if (Array.isArray(this.learningProgresses)) {
            data["learningProgresses"] = [];
            for (let item of this.learningProgresses)
                data["learningProgresses"].push(item.toJSON());
        }
        if (Array.isArray(this.registerStudies)) {
            data["registerStudies"] = [];
            for (let item of this.registerStudies)
                data["registerStudies"].push(item.toJSON());
        }
        if (Array.isArray(this.subjectDetails)) {
            data["subjectDetails"] = [];
            for (let item of this.subjectDetails)
                data["subjectDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubject {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
    courseSubjects?: CourseSubject[];
    learningProgresses?: LearningProgress[];
    registerStudies?: RegisterStudy[];
    subjectDetails?: SubjectDetail[];
}

export class CourseSubject implements ICourseSubject {
    id?: number;
    courseId?: number;
    subjectId?: number;
    course?: Course;
    subject?: Subject;

    constructor(data?: ICourseSubject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.subject = _data["subject"] ? Subject.fromJS(_data["subject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseSubject {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSubject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICourseSubject {
    id?: number;
    courseId?: number;
    subjectId?: number;
    course?: Course;
    subject?: Subject;
}

export class Course implements ICourse {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    creator?: User;
    bills?: Bill[];
    courseSubjects?: CourseSubject[];
    registerStudies?: RegisterStudy[];

    constructor(data?: ICourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.creatorId = _data["creatorId"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            if (Array.isArray(_data["bills"])) {
                this.bills = [] as any;
                for (let item of _data["bills"])
                    this.bills!.push(Bill.fromJS(item));
            }
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubject.fromJS(item));
            }
            if (Array.isArray(_data["registerStudies"])) {
                this.registerStudies = [] as any;
                for (let item of _data["registerStudies"])
                    this.registerStudies!.push(RegisterStudy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["creatorId"] = this.creatorId;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.bills)) {
            data["bills"] = [];
            for (let item of this.bills)
                data["bills"].push(item.toJSON());
        }
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        if (Array.isArray(this.registerStudies)) {
            data["registerStudies"] = [];
            for (let item of this.registerStudies)
                data["registerStudies"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourse {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    creator?: User;
    bills?: Bill[];
    courseSubjects?: CourseSubject[];
    registerStudies?: RegisterStudy[];
}

export class Bill implements IBill {
    id?: number;
    userId?: number;
    courseId?: number;
    price?: number;
    tradingCode?: string;
    createTime?: Date;
    billStatusId?: number;
    user?: User;
    course?: Course;

    constructor(data?: IBill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.price = _data["price"];
            this.tradingCode = _data["tradingCode"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.billStatusId = _data["billStatusId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Bill {
        data = typeof data === 'object' ? data : {};
        let result = new Bill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["price"] = this.price;
        data["tradingCode"] = this.tradingCode;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["billStatusId"] = this.billStatusId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBill {
    id?: number;
    userId?: number;
    courseId?: number;
    price?: number;
    tradingCode?: string;
    createTime?: Date;
    billStatusId?: number;
    user?: User;
    course?: Course;
}

export class RegisterStudy implements IRegisterStudy {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;
    user?: User;
    course?: Course;
    currentSubject?: Subject;
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];

    constructor(data?: IRegisterStudy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.currentSubjectId = _data["currentSubjectId"];
            this.isFinished = _data["isFinished"];
            this.registerTime = _data["registerTime"] ? new Date(_data["registerTime"].toString()) : <any>undefined;
            this.percentComplete = _data["percentComplete"];
            this.doneTime = _data["doneTime"] ? new Date(_data["doneTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.currentSubject = _data["currentSubject"] ? Subject.fromJS(_data["currentSubject"]) : <any>undefined;
            if (Array.isArray(_data["doHomeworks"])) {
                this.doHomeworks = [] as any;
                for (let item of _data["doHomeworks"])
                    this.doHomeworks!.push(DoHomework.fromJS(item));
            }
            if (Array.isArray(_data["learningProgresses"])) {
                this.learningProgresses = [] as any;
                for (let item of _data["learningProgresses"])
                    this.learningProgresses!.push(LearningProgress.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegisterStudy {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterStudy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["currentSubjectId"] = this.currentSubjectId;
        data["isFinished"] = this.isFinished;
        data["registerTime"] = this.registerTime ? this.registerTime.toISOString() : <any>undefined;
        data["percentComplete"] = this.percentComplete;
        data["doneTime"] = this.doneTime ? this.doneTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["currentSubject"] = this.currentSubject ? this.currentSubject.toJSON() : <any>undefined;
        if (Array.isArray(this.doHomeworks)) {
            data["doHomeworks"] = [];
            for (let item of this.doHomeworks)
                data["doHomeworks"].push(item.toJSON());
        }
        if (Array.isArray(this.learningProgresses)) {
            data["learningProgresses"] = [];
            for (let item of this.learningProgresses)
                data["learningProgresses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegisterStudy {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;
    user?: User;
    course?: Course;
    currentSubject?: Subject;
    doHomeworks?: DoHomework[];
    learningProgresses?: LearningProgress[];
}

export class DoHomework implements IDoHomework {
    id?: number;
    practiceId?: number;
    userId?: number;
    homeworkStatus?: HomeworkStatus;
    isFinished?: boolean;
    actualOutput?: string;
    doneTime?: Date;
    registerStudyId?: number;
    practice?: Practice;
    user?: User;
    registerStudy?: RegisterStudy;
    runTestCases?: RunTestCase[];

    constructor(data?: IDoHomework) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.practiceId = _data["practiceId"];
            this.userId = _data["userId"];
            this.homeworkStatus = _data["homeworkStatus"];
            this.isFinished = _data["isFinished"];
            this.actualOutput = _data["actualOutput"];
            this.doneTime = _data["doneTime"] ? new Date(_data["doneTime"].toString()) : <any>undefined;
            this.registerStudyId = _data["registerStudyId"];
            this.practice = _data["practice"] ? Practice.fromJS(_data["practice"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.registerStudy = _data["registerStudy"] ? RegisterStudy.fromJS(_data["registerStudy"]) : <any>undefined;
            if (Array.isArray(_data["runTestCases"])) {
                this.runTestCases = [] as any;
                for (let item of _data["runTestCases"])
                    this.runTestCases!.push(RunTestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DoHomework {
        data = typeof data === 'object' ? data : {};
        let result = new DoHomework();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["practiceId"] = this.practiceId;
        data["userId"] = this.userId;
        data["homeworkStatus"] = this.homeworkStatus;
        data["isFinished"] = this.isFinished;
        data["actualOutput"] = this.actualOutput;
        data["doneTime"] = this.doneTime ? this.doneTime.toISOString() : <any>undefined;
        data["registerStudyId"] = this.registerStudyId;
        data["practice"] = this.practice ? this.practice.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["registerStudy"] = this.registerStudy ? this.registerStudy.toJSON() : <any>undefined;
        if (Array.isArray(this.runTestCases)) {
            data["runTestCases"] = [];
            for (let item of this.runTestCases)
                data["runTestCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDoHomework {
    id?: number;
    practiceId?: number;
    userId?: number;
    homeworkStatus?: HomeworkStatus;
    isFinished?: boolean;
    actualOutput?: string;
    doneTime?: Date;
    registerStudyId?: number;
    practice?: Practice;
    user?: User;
    registerStudy?: RegisterStudy;
    runTestCases?: RunTestCase[];
}

export enum HomeworkStatus {
    NotStarted = "NotStarted",
    InProgress = "InProgress",
    Completed = "Completed",
    Overdue = "Overdue",
}

export class Practice implements IPractice {
    id?: number;
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;
    subjectDetail?: SubjectDetail;
    programingLanguage?: ProgramingLanguage;
    doHomeworks?: DoHomework[];
    testCases?: TestCase[];

    constructor(data?: IPractice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectDetailId = _data["subjectDetailId"];
            this.level = _data["level"];
            this.practiceCode = _data["practiceCode"];
            this.title = _data["title"];
            this.topic = _data["topic"];
            this.expectOutput = _data["expectOutput"];
            this.languageProgrammingId = _data["languageProgrammingId"];
            this.isRequired = _data["isRequired"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.mediumScore = _data["mediumScore"];
            this.subjectDetail = _data["subjectDetail"] ? SubjectDetail.fromJS(_data["subjectDetail"]) : <any>undefined;
            this.programingLanguage = _data["programingLanguage"] ? ProgramingLanguage.fromJS(_data["programingLanguage"]) : <any>undefined;
            if (Array.isArray(_data["doHomeworks"])) {
                this.doHomeworks = [] as any;
                for (let item of _data["doHomeworks"])
                    this.doHomeworks!.push(DoHomework.fromJS(item));
            }
            if (Array.isArray(_data["testCases"])) {
                this.testCases = [] as any;
                for (let item of _data["testCases"])
                    this.testCases!.push(TestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Practice {
        data = typeof data === 'object' ? data : {};
        let result = new Practice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectDetailId"] = this.subjectDetailId;
        data["level"] = this.level;
        data["practiceCode"] = this.practiceCode;
        data["title"] = this.title;
        data["topic"] = this.topic;
        data["expectOutput"] = this.expectOutput;
        data["languageProgrammingId"] = this.languageProgrammingId;
        data["isRequired"] = this.isRequired;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["mediumScore"] = this.mediumScore;
        data["subjectDetail"] = this.subjectDetail ? this.subjectDetail.toJSON() : <any>undefined;
        data["programingLanguage"] = this.programingLanguage ? this.programingLanguage.toJSON() : <any>undefined;
        if (Array.isArray(this.doHomeworks)) {
            data["doHomeworks"] = [];
            for (let item of this.doHomeworks)
                data["doHomeworks"].push(item.toJSON());
        }
        if (Array.isArray(this.testCases)) {
            data["testCases"] = [];
            for (let item of this.testCases)
                data["testCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPractice {
    id?: number;
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;
    subjectDetail?: SubjectDetail;
    programingLanguage?: ProgramingLanguage;
    doHomeworks?: DoHomework[];
    testCases?: TestCase[];
}

export enum Level {
    Beginner = "Beginner",
    Intermediate = "Intermediate",
    Advanced = "Advanced",
    Expert = "Expert",
}

export class ProgramingLanguage implements IProgramingLanguage {
    id?: number;
    languageName?: string;
    practices?: Practice[];
    testCases?: TestCase[];

    constructor(data?: IProgramingLanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageName = _data["languageName"];
            if (Array.isArray(_data["practices"])) {
                this.practices = [] as any;
                for (let item of _data["practices"])
                    this.practices!.push(Practice.fromJS(item));
            }
            if (Array.isArray(_data["testCases"])) {
                this.testCases = [] as any;
                for (let item of _data["testCases"])
                    this.testCases!.push(TestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramingLanguage {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramingLanguage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageName"] = this.languageName;
        if (Array.isArray(this.practices)) {
            data["practices"] = [];
            for (let item of this.practices)
                data["practices"].push(item.toJSON());
        }
        if (Array.isArray(this.testCases)) {
            data["testCases"] = [];
            for (let item of this.testCases)
                data["testCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProgramingLanguage {
    id?: number;
    languageName?: string;
    practices?: Practice[];
    testCases?: TestCase[];
}

export class TestCase implements ITestCase {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;
    programingLanguage?: ProgramingLanguage;
    practice?: Practice;
    runTestCases?: RunTestCase[];

    constructor(data?: ITestCase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.input = _data["input"];
            this.output = _data["output"];
            this.programingLanguageId = _data["programingLanguageId"];
            this.practiceId = _data["practiceId"];
            this.programingLanguage = _data["programingLanguage"] ? ProgramingLanguage.fromJS(_data["programingLanguage"]) : <any>undefined;
            this.practice = _data["practice"] ? Practice.fromJS(_data["practice"]) : <any>undefined;
            if (Array.isArray(_data["runTestCases"])) {
                this.runTestCases = [] as any;
                for (let item of _data["runTestCases"])
                    this.runTestCases!.push(RunTestCase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TestCase {
        data = typeof data === 'object' ? data : {};
        let result = new TestCase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["input"] = this.input;
        data["output"] = this.output;
        data["programingLanguageId"] = this.programingLanguageId;
        data["practiceId"] = this.practiceId;
        data["programingLanguage"] = this.programingLanguage ? this.programingLanguage.toJSON() : <any>undefined;
        data["practice"] = this.practice ? this.practice.toJSON() : <any>undefined;
        if (Array.isArray(this.runTestCases)) {
            data["runTestCases"] = [];
            for (let item of this.runTestCases)
                data["runTestCases"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITestCase {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;
    programingLanguage?: ProgramingLanguage;
    practice?: Practice;
    runTestCases?: RunTestCase[];
}

export class RunTestCase implements IRunTestCase {
    id?: number;
    doHomeworkId?: number;
    testCaseId?: number;
    result?: string;
    runTime?: number;
    doHomework?: DoHomework;
    testCase?: TestCase;

    constructor(data?: IRunTestCase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.doHomeworkId = _data["doHomeworkId"];
            this.testCaseId = _data["testCaseId"];
            this.result = _data["result"];
            this.runTime = _data["runTime"];
            this.doHomework = _data["doHomework"] ? DoHomework.fromJS(_data["doHomework"]) : <any>undefined;
            this.testCase = _data["testCase"] ? TestCase.fromJS(_data["testCase"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RunTestCase {
        data = typeof data === 'object' ? data : {};
        let result = new RunTestCase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["doHomeworkId"] = this.doHomeworkId;
        data["testCaseId"] = this.testCaseId;
        data["result"] = this.result;
        data["runTime"] = this.runTime;
        data["doHomework"] = this.doHomework ? this.doHomework.toJSON() : <any>undefined;
        data["testCase"] = this.testCase ? this.testCase.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRunTestCase {
    id?: number;
    doHomeworkId?: number;
    testCaseId?: number;
    result?: string;
    runTime?: number;
    doHomework?: DoHomework;
    testCase?: TestCase;
}

export class LearningProgress implements ILearningProgress {
    id?: number;
    userId?: number;
    registerStudyId?: number;
    currentSubjectId?: number;
    user?: User;
    registerStudy?: RegisterStudy;
    currentSubject?: Subject;

    constructor(data?: ILearningProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.registerStudyId = _data["registerStudyId"];
            this.currentSubjectId = _data["currentSubjectId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.registerStudy = _data["registerStudy"] ? RegisterStudy.fromJS(_data["registerStudy"]) : <any>undefined;
            this.currentSubject = _data["currentSubject"] ? Subject.fromJS(_data["currentSubject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LearningProgress {
        data = typeof data === 'object' ? data : {};
        let result = new LearningProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["registerStudyId"] = this.registerStudyId;
        data["currentSubjectId"] = this.currentSubjectId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["registerStudy"] = this.registerStudy ? this.registerStudy.toJSON() : <any>undefined;
        data["currentSubject"] = this.currentSubject ? this.currentSubject.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILearningProgress {
    id?: number;
    userId?: number;
    registerStudyId?: number;
    currentSubjectId?: number;
    user?: User;
    registerStudy?: RegisterStudy;
    currentSubject?: Subject;
}

export class Blog implements IBlog {
    id?: number;
    creatorId?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    image?: string;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlog[];
    likeBlogs?: LikeBlog[];

    constructor(data?: IBlog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorId = _data["creatorId"];
            this.content = _data["content"];
            this.title = _data["title"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.image = _data["image"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            if (Array.isArray(_data["commentBlogs"])) {
                this.commentBlogs = [] as any;
                for (let item of _data["commentBlogs"])
                    this.commentBlogs!.push(CommentBlog.fromJS(item));
            }
            if (Array.isArray(_data["likeBlogs"])) {
                this.likeBlogs = [] as any;
                for (let item of _data["likeBlogs"])
                    this.likeBlogs!.push(LikeBlog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Blog {
        data = typeof data === 'object' ? data : {};
        let result = new Blog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorId"] = this.creatorId;
        data["content"] = this.content;
        data["title"] = this.title;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["image"] = this.image;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        if (Array.isArray(this.commentBlogs)) {
            data["commentBlogs"] = [];
            for (let item of this.commentBlogs)
                data["commentBlogs"].push(item.toJSON());
        }
        if (Array.isArray(this.likeBlogs)) {
            data["likeBlogs"] = [];
            for (let item of this.likeBlogs)
                data["likeBlogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlog {
    id?: number;
    creatorId?: number;
    content?: string;
    title?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    image?: string;
    createTime?: Date;
    updateTime?: Date;
    creator?: User;
    commentBlogs?: CommentBlog[];
    likeBlogs?: LikeBlog[];
}

export class CommentBlog implements ICommentBlog {
    id?: number;
    blogId?: number;
    userId?: number;
    parentId?: number | undefined;
    content?: string;
    edited?: boolean;
    replyCount?: number;
    blog?: Blog;
    user?: User;
    parent?: CommentBlog;
    childs?: CommentBlog[];

    constructor(data?: ICommentBlog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blogId = _data["blogId"];
            this.userId = _data["userId"];
            this.parentId = _data["parentId"];
            this.content = _data["content"];
            this.edited = _data["edited"];
            this.replyCount = _data["replyCount"];
            this.blog = _data["blog"] ? Blog.fromJS(_data["blog"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.parent = _data["parent"] ? CommentBlog.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["childs"])) {
                this.childs = [] as any;
                for (let item of _data["childs"])
                    this.childs!.push(CommentBlog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommentBlog {
        data = typeof data === 'object' ? data : {};
        let result = new CommentBlog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blogId"] = this.blogId;
        data["userId"] = this.userId;
        data["parentId"] = this.parentId;
        data["content"] = this.content;
        data["edited"] = this.edited;
        data["replyCount"] = this.replyCount;
        data["blog"] = this.blog ? this.blog.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.childs)) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommentBlog {
    id?: number;
    blogId?: number;
    userId?: number;
    parentId?: number | undefined;
    content?: string;
    edited?: boolean;
    replyCount?: number;
    blog?: Blog;
    user?: User;
    parent?: CommentBlog;
    childs?: CommentBlog[];
}

export class LikeBlog implements ILikeBlog {
    id?: number;
    userId?: number;
    blogId?: number;
    unlike?: boolean;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    blog?: Blog;

    constructor(data?: ILikeBlog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.blogId = _data["blogId"];
            this.unlike = _data["unlike"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.blog = _data["blog"] ? Blog.fromJS(_data["blog"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LikeBlog {
        data = typeof data === 'object' ? data : {};
        let result = new LikeBlog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["blogId"] = this.blogId;
        data["unlike"] = this.unlike;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["blog"] = this.blog ? this.blog.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILikeBlog {
    id?: number;
    userId?: number;
    blogId?: number;
    unlike?: boolean;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
    blog?: Blog;
}

export class ConfirmEmail implements IConfirmEmail {
    id?: number;
    confirmCode?: string;
    expiryTime?: Date;
    userId?: number;
    isConfirm?: boolean;
    user?: User;

    constructor(data?: IConfirmEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.confirmCode = _data["confirmCode"];
            this.expiryTime = _data["expiryTime"] ? new Date(_data["expiryTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isConfirm = _data["isConfirm"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConfirmEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["confirmCode"] = this.confirmCode;
        data["expiryTime"] = this.expiryTime ? this.expiryTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isConfirm"] = this.isConfirm;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConfirmEmail {
    id?: number;
    confirmCode?: string;
    expiryTime?: Date;
    userId?: number;
    isConfirm?: boolean;
    user?: User;
}

export class Notification implements INotification {
    id?: number;
    userId?: number;
    image?: string;
    content?: string;
    link?: string;
    isSeen?: boolean;
    createTime?: Date;
    user?: User;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.image = _data["image"];
            this.content = _data["content"];
            this.link = _data["link"];
            this.isSeen = _data["isSeen"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["image"] = this.image;
        data["content"] = this.content;
        data["link"] = this.link;
        data["isSeen"] = this.isSeen;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotification {
    id?: number;
    userId?: number;
    image?: string;
    content?: string;
    link?: string;
    isSeen?: boolean;
    createTime?: Date;
    user?: User;
}

export class Permission implements IPermission {
    id?: number;
    userId?: number;
    roleId?: number;
    user?: User;
    role?: Role;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPermission {
    id?: number;
    userId?: number;
    roleId?: number;
    user?: User;
    role?: Role;
}

export class Role implements IRole {
    id?: number;
    roleCode?: string;
    roleName?: string;
    permissions?: Permission[];

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleCode = _data["roleCode"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleCode"] = this.roleCode;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRole {
    id?: number;
    roleCode?: string;
    roleName?: string;
    permissions?: Permission[];
}

export class RefreshToken implements IRefreshToken {
    id?: number;
    token?: string;
    expiryTime?: Date;
    userId?: number;
    user?: User;

    constructor(data?: IRefreshToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.token = _data["token"];
            this.expiryTime = _data["expiryTime"] ? new Date(_data["expiryTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RefreshToken {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["token"] = this.token;
        data["expiryTime"] = this.expiryTime ? this.expiryTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRefreshToken {
    id?: number;
    token?: string;
    expiryTime?: Date;
    userId?: number;
    user?: User;
}

export class CommentBlogMapping implements ICommentBlogMapping {
    id?: number;
    blogId?: number;
    userId?: number;
    parentId?: number;
    content?: string;
    edited?: boolean;
    user?: User;

    constructor(data?: ICommentBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blogId = _data["blogId"];
            this.userId = _data["userId"];
            this.parentId = _data["parentId"];
            this.content = _data["content"];
            this.edited = _data["edited"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentBlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CommentBlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blogId"] = this.blogId;
        data["userId"] = this.userId;
        data["parentId"] = this.parentId;
        data["content"] = this.content;
        data["edited"] = this.edited;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentBlogMapping {
    id?: number;
    blogId?: number;
    userId?: number;
    parentId?: number;
    content?: string;
    edited?: boolean;
    user?: User;
}

export class Result implements IResult {
    status?: ResultStatus;
    error?: string | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["error"] = this.error;
        return data;
    }
}

export interface IResult {
    status?: ResultStatus;
    error?: string | undefined;
}

export enum ResultStatus {
    Success = "Success",
    Failure = "Failure",
    NotFound = "NotFound",
    Forbidden = "Forbidden",
}

export class BlogCreate implements IBlogCreate {
    content?: string;
    title?: string;
    image?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;

    constructor(data?: IBlogCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.title = _data["title"];
            this.image = _data["image"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BlogCreate {
        data = typeof data === 'object' ? data : {};
        let result = new BlogCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["title"] = this.title;
        data["image"] = this.image;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBlogCreate {
    content?: string;
    title?: string;
    image?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
}

export class BlogUpdate implements IBlogUpdate {
    id?: number;
    content?: string;
    title?: string;
    image?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;

    constructor(data?: IBlogUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
            this.title = _data["title"];
            this.image = _data["image"];
            this.numberOfLikes = _data["numberOfLikes"];
            this.numberOfComments = _data["numberOfComments"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BlogUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new BlogUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        data["title"] = this.title;
        data["image"] = this.image;
        data["numberOfLikes"] = this.numberOfLikes;
        data["numberOfComments"] = this.numberOfComments;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBlogUpdate {
    id?: number;
    content?: string;
    title?: string;
    image?: string;
    numberOfLikes?: number;
    numberOfComments?: number;
    createTime?: Date;
}

export class PagingModelOfCertificateMapping implements IPagingModelOfCertificateMapping {
    items?: CertificateMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfCertificateMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CertificateMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfCertificateMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfCertificateMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfCertificateMapping {
    items?: CertificateMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CertificateMapping implements ICertificateMapping {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;

    constructor(data?: ICertificateMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): CertificateMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateTypeId"] = this.certificateTypeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        return data;
    }
}

export interface ICertificateMapping {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;
}

export class CertificateCreate implements ICertificateCreate {
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;

    constructor(data?: ICertificateCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificateTypeId = _data["certificateTypeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): CertificateCreate {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificateTypeId"] = this.certificateTypeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        return data;
    }
}

export interface ICertificateCreate {
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;
}

export class CertificateUpdate implements ICertificateUpdate {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;

    constructor(data?: ICertificateUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): CertificateUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["certificateTypeId"] = this.certificateTypeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        return data;
    }
}

export interface ICertificateUpdate {
    id?: number;
    certificateTypeId?: number;
    name?: string;
    description?: string;
    image?: string;
}

export class PagingModelOfCertificateTypeMapping implements IPagingModelOfCertificateTypeMapping {
    items?: CertificateTypeMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfCertificateTypeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CertificateTypeMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfCertificateTypeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfCertificateTypeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfCertificateTypeMapping {
    items?: CertificateTypeMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CertificateTypeMapping implements ICertificateTypeMapping {
    id?: number;
    name?: string;

    constructor(data?: ICertificateTypeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CertificateTypeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateTypeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICertificateTypeMapping {
    id?: number;
    name?: string;
}

export class CertificateTypeCreate implements ICertificateTypeCreate {
    name?: string;

    constructor(data?: ICertificateTypeCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CertificateTypeCreate {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateTypeCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICertificateTypeCreate {
    name?: string;
}

export class CertificateTypeUpdate implements ICertificateTypeUpdate {
    id?: number;
    name?: string;

    constructor(data?: ICertificateTypeUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CertificateTypeUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateTypeUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICertificateTypeUpdate {
    id?: number;
    name?: string;
}

export class PagingModelOfCommentBlogMapping implements IPagingModelOfCommentBlogMapping {
    items?: CommentBlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfCommentBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommentBlogMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfCommentBlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfCommentBlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfCommentBlogMapping {
    items?: CommentBlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CommentBlogCreate implements ICommentBlogCreate {
    blogId?: number;
    parentId?: number | undefined;
    content?: string;

    constructor(data?: ICommentBlogCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blogId = _data["blogId"];
            this.parentId = _data["parentId"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CommentBlogCreate {
        data = typeof data === 'object' ? data : {};
        let result = new CommentBlogCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blogId"] = this.blogId;
        data["parentId"] = this.parentId;
        data["content"] = this.content;
        return data;
    }
}

export interface ICommentBlogCreate {
    blogId?: number;
    parentId?: number | undefined;
    content?: string;
}

export class CommentBlogUpdate implements ICommentBlogUpdate {
    id?: number;
    content?: string;

    constructor(data?: ICommentBlogUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CommentBlogUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CommentBlogUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["content"] = this.content;
        return data;
    }
}

export interface ICommentBlogUpdate {
    id?: number;
    content?: string;
}

export class PagingModelOfCourseMapping implements IPagingModelOfCourseMapping {
    items?: CourseMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfCourseMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfCourseMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfCourseMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfCourseMapping {
    items?: CourseMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CourseMapping implements ICourseMapping {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];

    constructor(data?: ICourseMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.creatorId = _data["creatorId"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CourseMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["creatorId"] = this.creatorId;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseMapping {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];
}

export class CourseSubjectMapping implements ICourseSubjectMapping {
    id?: number;
    courseId?: number;
    subjectId?: number;
    subject?: SubjectMapping | undefined;

    constructor(data?: ICourseSubjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.courseId = _data["courseId"];
            this.subjectId = _data["subjectId"];
            this.subject = _data["subject"] ? SubjectMapping.fromJS(_data["subject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseSubjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSubjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["courseId"] = this.courseId;
        data["subjectId"] = this.subjectId;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICourseSubjectMapping {
    id?: number;
    courseId?: number;
    subjectId?: number;
    subject?: SubjectMapping | undefined;
}

export class SubjectMapping implements ISubjectMapping {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
    subjectDetails?: SubjectDetailMapping[];

    constructor(data?: ISubjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["subjectDetails"])) {
                this.subjectDetails = [] as any;
                for (let item of _data["subjectDetails"])
                    this.subjectDetails!.push(SubjectDetailMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.subjectDetails)) {
            data["subjectDetails"] = [];
            for (let item of this.subjectDetails)
                data["subjectDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubjectMapping {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
    subjectDetails?: SubjectDetailMapping[];
}

export class SubjectDetailMapping implements ISubjectDetailMapping {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;

    constructor(data?: ISubjectDetailMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.name = _data["name"];
            this.isFinished = _data["isFinished"];
            this.linkVideo = _data["linkVideo"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectDetailMapping {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDetailMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["name"] = this.name;
        data["isFinished"] = this.isFinished;
        data["linkVideo"] = this.linkVideo;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectDetailMapping {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;
}

export class CourseCreate implements ICourseCreate {
    name?: string;
    introduce?: string;
    imageCourse?: string;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];

    constructor(data?: ICourseCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseCreate {
        data = typeof data === 'object' ? data : {};
        let result = new CourseCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseCreate {
    name?: string;
    introduce?: string;
    imageCourse?: string;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];
}

export class CourseUpdate implements ICourseUpdate {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];

    constructor(data?: ICourseUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.introduce = _data["introduce"];
            this.imageCourse = _data["imageCourse"];
            this.creatorId = _data["creatorId"];
            this.code = _data["code"];
            this.price = _data["price"];
            this.totalCourseDuration = _data["totalCourseDuration"];
            this.numberOfStudent = _data["numberOfStudent"];
            this.numberOfPurchases = _data["numberOfPurchases"];
            if (Array.isArray(_data["courseSubjects"])) {
                this.courseSubjects = [] as any;
                for (let item of _data["courseSubjects"])
                    this.courseSubjects!.push(CourseSubjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CourseUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["introduce"] = this.introduce;
        data["imageCourse"] = this.imageCourse;
        data["creatorId"] = this.creatorId;
        data["code"] = this.code;
        data["price"] = this.price;
        data["totalCourseDuration"] = this.totalCourseDuration;
        data["numberOfStudent"] = this.numberOfStudent;
        data["numberOfPurchases"] = this.numberOfPurchases;
        if (Array.isArray(this.courseSubjects)) {
            data["courseSubjects"] = [];
            for (let item of this.courseSubjects)
                data["courseSubjects"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseUpdate {
    id?: number;
    name?: string;
    introduce?: string;
    imageCourse?: string;
    creatorId?: number;
    code?: string;
    price?: number;
    totalCourseDuration?: number;
    numberOfStudent?: number;
    numberOfPurchases?: number;
    courseSubjects?: CourseSubjectMapping[];
}

export class PagingModelOfDistrictMapping implements IPagingModelOfDistrictMapping {
    items?: DistrictMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfDistrictMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DistrictMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfDistrictMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfDistrictMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfDistrictMapping {
    items?: DistrictMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class DistrictMapping implements IDistrictMapping {
    id?: number;
    provinceId?: number;
    name?: string;

    constructor(data?: IDistrictMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provinceId = _data["provinceId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DistrictMapping {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provinceId"] = this.provinceId;
        data["name"] = this.name;
        return data;
    }
}

export interface IDistrictMapping {
    id?: number;
    provinceId?: number;
    name?: string;
}

export class DistrictCreate implements IDistrictCreate {
    provinceId?: number;
    name?: string;

    constructor(data?: IDistrictCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provinceId = _data["provinceId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DistrictCreate {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provinceId"] = this.provinceId;
        data["name"] = this.name;
        return data;
    }
}

export interface IDistrictCreate {
    provinceId?: number;
    name?: string;
}

export class DistrictUpdate implements IDistrictUpdate {
    id?: number;
    provinceId?: number;
    name?: string;

    constructor(data?: IDistrictUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provinceId = _data["provinceId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DistrictUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provinceId"] = this.provinceId;
        data["name"] = this.name;
        return data;
    }
}

export interface IDistrictUpdate {
    id?: number;
    provinceId?: number;
    name?: string;
}

export class PagingModelOfLikeBlogMapping implements IPagingModelOfLikeBlogMapping {
    items?: LikeBlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfLikeBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LikeBlogMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfLikeBlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfLikeBlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfLikeBlogMapping {
    items?: LikeBlogMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class LikeBlogMapping implements ILikeBlogMapping {
    id?: number;
    userId?: number;
    blogId?: number;
    unlike?: boolean;
    createTime?: Date;
    updateTime?: Date;
    user?: User;

    constructor(data?: ILikeBlogMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.blogId = _data["blogId"];
            this.unlike = _data["unlike"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LikeBlogMapping {
        data = typeof data === 'object' ? data : {};
        let result = new LikeBlogMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["blogId"] = this.blogId;
        data["unlike"] = this.unlike;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILikeBlogMapping {
    id?: number;
    userId?: number;
    blogId?: number;
    unlike?: boolean;
    createTime?: Date;
    updateTime?: Date;
    user?: User;
}

export class LikeBlogCreate implements ILikeBlogCreate {
    blogId?: number;

    constructor(data?: ILikeBlogCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blogId = _data["blogId"];
        }
    }

    static fromJS(data: any): LikeBlogCreate {
        data = typeof data === 'object' ? data : {};
        let result = new LikeBlogCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blogId"] = this.blogId;
        return data;
    }
}

export interface ILikeBlogCreate {
    blogId?: number;
}

export class LikeBlogUpdate implements ILikeBlogUpdate {
    id?: number;
    blogId?: number;

    constructor(data?: ILikeBlogUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blogId = _data["blogId"];
        }
    }

    static fromJS(data: any): LikeBlogUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new LikeBlogUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blogId"] = this.blogId;
        return data;
    }
}

export interface ILikeBlogUpdate {
    id?: number;
    blogId?: number;
}

export class PagingModelOfPracticeMapping implements IPagingModelOfPracticeMapping {
    items?: PracticeMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfPracticeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PracticeMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfPracticeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfPracticeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfPracticeMapping {
    items?: PracticeMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PracticeMapping implements IPracticeMapping {
    id?: number;
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;

    constructor(data?: IPracticeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectDetailId = _data["subjectDetailId"];
            this.level = _data["level"];
            this.practiceCode = _data["practiceCode"];
            this.title = _data["title"];
            this.topic = _data["topic"];
            this.expectOutput = _data["expectOutput"];
            this.languageProgrammingId = _data["languageProgrammingId"];
            this.isRequired = _data["isRequired"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.mediumScore = _data["mediumScore"];
        }
    }

    static fromJS(data: any): PracticeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PracticeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectDetailId"] = this.subjectDetailId;
        data["level"] = this.level;
        data["practiceCode"] = this.practiceCode;
        data["title"] = this.title;
        data["topic"] = this.topic;
        data["expectOutput"] = this.expectOutput;
        data["languageProgrammingId"] = this.languageProgrammingId;
        data["isRequired"] = this.isRequired;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["mediumScore"] = this.mediumScore;
        return data;
    }
}

export interface IPracticeMapping {
    id?: number;
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;
}

export class PracticeCreate implements IPracticeCreate {
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;

    constructor(data?: IPracticeCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectDetailId = _data["subjectDetailId"];
            this.level = _data["level"];
            this.practiceCode = _data["practiceCode"];
            this.title = _data["title"];
            this.topic = _data["topic"];
            this.expectOutput = _data["expectOutput"];
            this.languageProgrammingId = _data["languageProgrammingId"];
            this.isRequired = _data["isRequired"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.mediumScore = _data["mediumScore"];
        }
    }

    static fromJS(data: any): PracticeCreate {
        data = typeof data === 'object' ? data : {};
        let result = new PracticeCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectDetailId"] = this.subjectDetailId;
        data["level"] = this.level;
        data["practiceCode"] = this.practiceCode;
        data["title"] = this.title;
        data["topic"] = this.topic;
        data["expectOutput"] = this.expectOutput;
        data["languageProgrammingId"] = this.languageProgrammingId;
        data["isRequired"] = this.isRequired;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["mediumScore"] = this.mediumScore;
        return data;
    }
}

export interface IPracticeCreate {
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;
}

export class PracticeUpdate implements IPracticeUpdate {
    id?: number;
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;

    constructor(data?: IPracticeUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectDetailId = _data["subjectDetailId"];
            this.level = _data["level"];
            this.practiceCode = _data["practiceCode"];
            this.title = _data["title"];
            this.topic = _data["topic"];
            this.expectOutput = _data["expectOutput"];
            this.languageProgrammingId = _data["languageProgrammingId"];
            this.isRequired = _data["isRequired"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.mediumScore = _data["mediumScore"];
        }
    }

    static fromJS(data: any): PracticeUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new PracticeUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectDetailId"] = this.subjectDetailId;
        data["level"] = this.level;
        data["practiceCode"] = this.practiceCode;
        data["title"] = this.title;
        data["topic"] = this.topic;
        data["expectOutput"] = this.expectOutput;
        data["languageProgrammingId"] = this.languageProgrammingId;
        data["isRequired"] = this.isRequired;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["mediumScore"] = this.mediumScore;
        return data;
    }
}

export interface IPracticeUpdate {
    id?: number;
    subjectDetailId?: number;
    level?: Level;
    practiceCode?: string;
    title?: string;
    topic?: string;
    expectOutput?: string;
    languageProgrammingId?: number;
    isRequired?: boolean;
    createTime?: Date;
    updateTime?: Date;
    isDeleted?: boolean;
    mediumScore?: number;
}

export class PagingModelOfProgramingLanguageMapping implements IPagingModelOfProgramingLanguageMapping {
    items?: ProgramingLanguageMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfProgramingLanguageMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProgramingLanguageMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfProgramingLanguageMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfProgramingLanguageMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfProgramingLanguageMapping {
    items?: ProgramingLanguageMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProgramingLanguageMapping implements IProgramingLanguageMapping {
    id?: number;
    languageName?: string;

    constructor(data?: IProgramingLanguageMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ProgramingLanguageMapping {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramingLanguageMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IProgramingLanguageMapping {
    id?: number;
    languageName?: string;
}

export class ProgramingLanguageCreate implements IProgramingLanguageCreate {
    languageName?: string;

    constructor(data?: IProgramingLanguageCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ProgramingLanguageCreate {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramingLanguageCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IProgramingLanguageCreate {
    languageName?: string;
}

export class ProgramingLanguageUpdate implements IProgramingLanguageUpdate {
    id?: number;
    languageName?: string;

    constructor(data?: IProgramingLanguageUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ProgramingLanguageUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramingLanguageUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IProgramingLanguageUpdate {
    id?: number;
    languageName?: string;
}

export class PagingModelOfProvinceMapping implements IPagingModelOfProvinceMapping {
    items?: ProvinceMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfProvinceMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProvinceMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfProvinceMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfProvinceMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfProvinceMapping {
    items?: ProvinceMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProvinceMapping implements IProvinceMapping {
    id?: number;
    name?: string;

    constructor(data?: IProvinceMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProvinceMapping {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProvinceMapping {
    id?: number;
    name?: string;
}

export class ProvinceCreate implements IProvinceCreate {
    name?: string;

    constructor(data?: IProvinceCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProvinceCreate {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IProvinceCreate {
    name?: string;
}

export class ProvinceUpdate implements IProvinceUpdate {
    id?: number;
    name?: string;

    constructor(data?: IProvinceUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProvinceUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProvinceUpdate {
    id?: number;
    name?: string;
}

export class PagingModelOfRegisterStudyMapping implements IPagingModelOfRegisterStudyMapping {
    items?: RegisterStudyMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfRegisterStudyMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RegisterStudyMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfRegisterStudyMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfRegisterStudyMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfRegisterStudyMapping {
    items?: RegisterStudyMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RegisterStudyMapping implements IRegisterStudyMapping {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;

    constructor(data?: IRegisterStudyMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.currentSubjectId = _data["currentSubjectId"];
            this.isFinished = _data["isFinished"];
            this.registerTime = _data["registerTime"] ? new Date(_data["registerTime"].toString()) : <any>undefined;
            this.percentComplete = _data["percentComplete"];
            this.doneTime = _data["doneTime"] ? new Date(_data["doneTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RegisterStudyMapping {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterStudyMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["currentSubjectId"] = this.currentSubjectId;
        data["isFinished"] = this.isFinished;
        data["registerTime"] = this.registerTime ? this.registerTime.toISOString() : <any>undefined;
        data["percentComplete"] = this.percentComplete;
        data["doneTime"] = this.doneTime ? this.doneTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRegisterStudyMapping {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;
}

export class RegisterStudyCreate implements IRegisterStudyCreate {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;

    constructor(data?: IRegisterStudyCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.currentSubjectId = _data["currentSubjectId"];
            this.isFinished = _data["isFinished"];
            this.registerTime = _data["registerTime"] ? new Date(_data["registerTime"].toString()) : <any>undefined;
            this.percentComplete = _data["percentComplete"];
            this.doneTime = _data["doneTime"] ? new Date(_data["doneTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RegisterStudyCreate {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterStudyCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["currentSubjectId"] = this.currentSubjectId;
        data["isFinished"] = this.isFinished;
        data["registerTime"] = this.registerTime ? this.registerTime.toISOString() : <any>undefined;
        data["percentComplete"] = this.percentComplete;
        data["doneTime"] = this.doneTime ? this.doneTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRegisterStudyCreate {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;
}

export class RegisterStudyUpdate implements IRegisterStudyUpdate {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;

    constructor(data?: IRegisterStudyUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.courseId = _data["courseId"];
            this.currentSubjectId = _data["currentSubjectId"];
            this.isFinished = _data["isFinished"];
            this.registerTime = _data["registerTime"] ? new Date(_data["registerTime"].toString()) : <any>undefined;
            this.percentComplete = _data["percentComplete"];
            this.doneTime = _data["doneTime"] ? new Date(_data["doneTime"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RegisterStudyUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterStudyUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["courseId"] = this.courseId;
        data["currentSubjectId"] = this.currentSubjectId;
        data["isFinished"] = this.isFinished;
        data["registerTime"] = this.registerTime ? this.registerTime.toISOString() : <any>undefined;
        data["percentComplete"] = this.percentComplete;
        data["doneTime"] = this.doneTime ? this.doneTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRegisterStudyUpdate {
    id?: number;
    userId?: number;
    courseId?: number;
    currentSubjectId?: number;
    isFinished?: boolean;
    registerTime?: Date;
    percentComplete?: number;
    doneTime?: Date | undefined;
    isActive?: boolean;
}

export class PagingModelOfRoleMapping implements IPagingModelOfRoleMapping {
    items?: RoleMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfRoleMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfRoleMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfRoleMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfRoleMapping {
    items?: RoleMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RoleMapping implements IRoleMapping {
    id?: number;
    roleCode?: string;
    roleName?: string;

    constructor(data?: IRoleMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleCode = _data["roleCode"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): RoleMapping {
        data = typeof data === 'object' ? data : {};
        let result = new RoleMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleCode"] = this.roleCode;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IRoleMapping {
    id?: number;
    roleCode?: string;
    roleName?: string;
}

export class RoleCreate implements IRoleCreate {
    roleCode?: string;
    roleName?: string;

    constructor(data?: IRoleCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleCode = _data["roleCode"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): RoleCreate {
        data = typeof data === 'object' ? data : {};
        let result = new RoleCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleCode"] = this.roleCode;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IRoleCreate {
    roleCode?: string;
    roleName?: string;
}

export class RoleUpdate implements IRoleUpdate {
    id?: number;
    roleCode?: string;
    roleName?: string;

    constructor(data?: IRoleUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleCode = _data["roleCode"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): RoleUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new RoleUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleCode"] = this.roleCode;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IRoleUpdate {
    id?: number;
    roleCode?: string;
    roleName?: string;
}

export class PagingModelOfSubjectMapping implements IPagingModelOfSubjectMapping {
    items?: SubjectMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfSubjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubjectMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfSubjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfSubjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfSubjectMapping {
    items?: SubjectMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SubjectCreate implements ISubjectCreate {
    name!: string;
    symbol!: string;
    isActive?: boolean;

    constructor(data?: ISubjectCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectCreate {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectCreate {
    name: string;
    symbol: string;
    isActive?: boolean;
}

export class SubjectUpdate implements ISubjectUpdate {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;

    constructor(data?: ISubjectUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectUpdate {
    id?: number;
    name?: string;
    symbol?: string;
    isActive?: boolean;
}

export class PagingModelOfSubjectDetailMapping implements IPagingModelOfSubjectDetailMapping {
    items?: SubjectDetailMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfSubjectDetailMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubjectDetailMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfSubjectDetailMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfSubjectDetailMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfSubjectDetailMapping {
    items?: SubjectDetailMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SubjectDetailCreate implements ISubjectDetailCreate {
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;

    constructor(data?: ISubjectDetailCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectId = _data["subjectId"];
            this.name = _data["name"];
            this.isFinished = _data["isFinished"];
            this.linkVideo = _data["linkVideo"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectDetailCreate {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDetailCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectId"] = this.subjectId;
        data["name"] = this.name;
        data["isFinished"] = this.isFinished;
        data["linkVideo"] = this.linkVideo;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectDetailCreate {
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;
}

export class SubjectDetailUpdate implements ISubjectDetailUpdate {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;

    constructor(data?: ISubjectDetailUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.name = _data["name"];
            this.isFinished = _data["isFinished"];
            this.linkVideo = _data["linkVideo"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubjectDetailUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDetailUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["name"] = this.name;
        data["isFinished"] = this.isFinished;
        data["linkVideo"] = this.linkVideo;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ISubjectDetailUpdate {
    id?: number;
    subjectId?: number;
    name?: string;
    isFinished?: boolean;
    linkVideo?: string;
    isActive?: boolean;
}

export class PagingModelOfTestCaseMapping implements IPagingModelOfTestCaseMapping {
    items?: TestCaseMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfTestCaseMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TestCaseMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfTestCaseMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfTestCaseMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfTestCaseMapping {
    items?: TestCaseMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TestCaseMapping implements ITestCaseMapping {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;

    constructor(data?: ITestCaseMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.input = _data["input"];
            this.output = _data["output"];
            this.programingLanguageId = _data["programingLanguageId"];
            this.practiceId = _data["practiceId"];
        }
    }

    static fromJS(data: any): TestCaseMapping {
        data = typeof data === 'object' ? data : {};
        let result = new TestCaseMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["input"] = this.input;
        data["output"] = this.output;
        data["programingLanguageId"] = this.programingLanguageId;
        data["practiceId"] = this.practiceId;
        return data;
    }
}

export interface ITestCaseMapping {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;
}

export class TestCaseCreate implements ITestCaseCreate {
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;

    constructor(data?: ITestCaseCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"];
            this.output = _data["output"];
            this.programingLanguageId = _data["programingLanguageId"];
            this.practiceId = _data["practiceId"];
        }
    }

    static fromJS(data: any): TestCaseCreate {
        data = typeof data === 'object' ? data : {};
        let result = new TestCaseCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input;
        data["output"] = this.output;
        data["programingLanguageId"] = this.programingLanguageId;
        data["practiceId"] = this.practiceId;
        return data;
    }
}

export interface ITestCaseCreate {
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;
}

export class TestCaseUpdate implements ITestCaseUpdate {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;

    constructor(data?: ITestCaseUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.input = _data["input"];
            this.output = _data["output"];
            this.programingLanguageId = _data["programingLanguageId"];
            this.practiceId = _data["practiceId"];
        }
    }

    static fromJS(data: any): TestCaseUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new TestCaseUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["input"] = this.input;
        data["output"] = this.output;
        data["programingLanguageId"] = this.programingLanguageId;
        data["practiceId"] = this.practiceId;
        return data;
    }
}

export interface ITestCaseUpdate {
    id?: number;
    input?: string;
    output?: string;
    programingLanguageId?: number;
    practiceId?: number;
}

export class PagingModelOfUserMapping implements IPagingModelOfUserMapping {
    items?: UserMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfUserMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfUserMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfUserMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfUserMapping {
    items?: UserMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UserMapping implements IUserMapping {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    createTime?: Date;
    avatar?: string | undefined;
    email?: string;
    updateTime?: Date;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    userStatus?: UserStatus;
    district?: DistrictMapping;
    province?: ProvinceMapping;
    certificate?: CertificateMapping;
    ward?: WardMapping;
    permissions?: PermissionMapping[];

    constructor(data?: IUserMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.certificateId = _data["certificateId"];
            this.wardId = _data["wardId"];
            this.username = _data["username"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.email = _data["email"];
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.address = _data["address"];
            this.userStatus = _data["userStatus"];
            this.district = _data["district"] ? DistrictMapping.fromJS(_data["district"]) : <any>undefined;
            this.province = _data["province"] ? ProvinceMapping.fromJS(_data["province"]) : <any>undefined;
            this.certificate = _data["certificate"] ? CertificateMapping.fromJS(_data["certificate"]) : <any>undefined;
            this.ward = _data["ward"] ? WardMapping.fromJS(_data["ward"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMapping {
        data = typeof data === 'object' ? data : {};
        let result = new UserMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["certificateId"] = this.certificateId;
        data["wardId"] = this.wardId;
        data["username"] = this.username;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["email"] = this.email;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["address"] = this.address;
        data["userStatus"] = this.userStatus;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["certificate"] = this.certificate ? this.certificate.toJSON() : <any>undefined;
        data["ward"] = this.ward ? this.ward.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserMapping {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    createTime?: Date;
    avatar?: string | undefined;
    email?: string;
    updateTime?: Date;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    userStatus?: UserStatus;
    district?: DistrictMapping;
    province?: ProvinceMapping;
    certificate?: CertificateMapping;
    ward?: WardMapping;
    permissions?: PermissionMapping[];
}

export class WardMapping implements IWardMapping {
    id?: number;
    districtId?: number;
    name?: string;

    constructor(data?: IWardMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WardMapping {
        data = typeof data === 'object' ? data : {};
        let result = new WardMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["name"] = this.name;
        return data;
    }
}

export interface IWardMapping {
    id?: number;
    districtId?: number;
    name?: string;
}

export class PermissionMapping implements IPermissionMapping {
    id?: number;
    userId?: number;
    roleId?: number;
    role?: RoleMapping;

    constructor(data?: IPermissionMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.role = _data["role"] ? RoleMapping.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPermissionMapping {
    id?: number;
    userId?: number;
    roleId?: number;
    role?: RoleMapping;
}

export class UserCreate implements IUserCreate {
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    avatar?: string | undefined;
    email?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    password?: string;
    userStatus?: UserStatus;
    permissions?: PermissionMapping[];

    constructor(data?: IUserCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.certificateId = _data["certificateId"];
            this.wardId = _data["wardId"];
            this.username = _data["username"];
            this.avatar = _data["avatar"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.address = _data["address"];
            this.password = _data["password"];
            this.userStatus = _data["userStatus"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserCreate {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["certificateId"] = this.certificateId;
        data["wardId"] = this.wardId;
        data["username"] = this.username;
        data["avatar"] = this.avatar;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["address"] = this.address;
        data["password"] = this.password;
        data["userStatus"] = this.userStatus;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserCreate {
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    avatar?: string | undefined;
    email?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    password?: string;
    userStatus?: UserStatus;
    permissions?: PermissionMapping[];
}

export class UserUpdate implements IUserUpdate {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    avatar?: string | undefined;
    email?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    userStatus?: UserStatus;
    permissions?: PermissionMapping[];

    constructor(data?: IUserUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.certificateId = _data["certificateId"];
            this.wardId = _data["wardId"];
            this.username = _data["username"];
            this.avatar = _data["avatar"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.address = _data["address"];
            this.userStatus = _data["userStatus"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["certificateId"] = this.certificateId;
        data["wardId"] = this.wardId;
        data["username"] = this.username;
        data["avatar"] = this.avatar;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["address"] = this.address;
        data["userStatus"] = this.userStatus;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserUpdate {
    id?: number;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    certificateId?: number | undefined;
    wardId?: number | undefined;
    username?: string;
    avatar?: string | undefined;
    email?: string;
    fullName?: string;
    dateOfBirth?: Date;
    isActive?: boolean;
    address?: string | undefined;
    userStatus?: UserStatus;
    permissions?: PermissionMapping[];
}

export class PagingModelOfWardMapping implements IPagingModelOfWardMapping {
    items?: WardMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagingModelOfWardMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WardMapping.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagingModelOfWardMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModelOfWardMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagingModelOfWardMapping {
    items?: WardMapping[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WardCreate implements IWardCreate {
    districtId?: number;
    name?: string;

    constructor(data?: IWardCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.districtId = _data["districtId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WardCreate {
        data = typeof data === 'object' ? data : {};
        let result = new WardCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["districtId"] = this.districtId;
        data["name"] = this.name;
        return data;
    }
}

export interface IWardCreate {
    districtId?: number;
    name?: string;
}

export class WardUpdate implements IWardUpdate {
    id?: number;
    districtId?: number;
    name?: string;

    constructor(data?: IWardUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.districtId = _data["districtId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WardUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new WardUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["districtId"] = this.districtId;
        data["name"] = this.name;
        return data;
    }
}

export interface IWardUpdate {
    id?: number;
    districtId?: number;
    name?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}